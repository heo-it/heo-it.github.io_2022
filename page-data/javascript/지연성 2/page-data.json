{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/javascript/지연성 2/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2>결과를 만드는 함수 reduce, take</h2>\n<ul>\n<li>기존 배열을 깨뜨려서(=변형시켜서) 연산을 하기 때문에 결과를 만드는 함수라고 한다.</li>\n<li>map, filter처럼 지연성을 가진다고 하기는 어렵지만, 결과를 만드는 시작점을 만들기 때문에 iterator의 값을 꺼내어 연산을 시작한다.</li>\n</ul>\n<h3>queryString 함수 만들기</h3>\n<p>reduce를 응용해서 객체로 부터 url의 queryString을 만드는 함수 queryStr 구현</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const queryStr = pipe(\n\tObject.entries,\n\tmap(([k, v]) =&gt; `${k}=${v}`),\n\treduce((a, b) =&gt; `${a}&amp;${b}`)\n);\n\nlog(queryStr({ limit: 10, offset: 10, type: &#39;notice&#39; })</code>\n        </deckgo-highlight-code>\n<h3>Array.prototype.join보다 다형성이 높은 join</h3>\n<p>기존 Array에서 제공하는 join함수는 지연평가를 제공하지 않는다. Iterator를 활용하여 더 다형성 높은 join함수를 만들 수 있다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const join = curry((sep = &#39;,&#39;, iter) =&gt; reduce((a, b) =&gt; `${a}${sep}${b}`, iter));</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const queryStr = pipe(\n\tObject.entries,\n\tmap(([k, v]) =&gt; `${k}=${v}`),\n\tjoin(&#39;&amp;&#39;)\n);\n\nlog(queryStr({ limit: 10, offset: 10, type: &#39;notice&#39; })</code>\n        </deckgo-highlight-code>\n<ul>\n<li>generator 함수에서의 join</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function *a() {\n\tyield 10;\n\tyield 11;\n\tyield 12;\n\tyield 13;\n}\n\njoin(&#39; - &#39;, a());</code>\n        </deckgo-highlight-code>\n<ul>\n<li>지연성을 가진 L.map과 L.entries 적용하기</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">L.entries = function *(obj) {\n\tfor (const k in obj) yield [k, obj[k]];\n}\n\nconst queryStr = pipe(\n\tL.entries,\n\tL.map(([k, v]) =&gt; `${k}=${v}`),\n\tjoin(&#39;&amp;&#39;)\n);\n\nlog(queryStr({ limit: 10, offset: 10, type: &#39;notice&#39; });</code>\n        </deckgo-highlight-code>\n<ul>\n<li>join으로 넘어갈 당시에 인자값은 iterable해서 실제 값이 생성되기 전이므로 지연성을 가짐.</li>\n</ul>\n<h2>take, find</h2>\n<blockquote>\n<p><strong>find함수</strong>: take로 결론을 만들어내는 함수 이다.</p>\n</blockquote>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const users = [\n    {age: 32},\n    {age: 31},\n    {age: 37},\n    {age: 28},\n    {age: 25},\n    {age: 32},\n    {age: 31},\n    {age: 37}\n];\n\nconst find = curry((f, iter) =&gt; go(\n\titer,\n\tL.filter(f),\n\ttake(1),\n\t([a]) =&gt; a\n));\n\nlog(find(u =&gt; u.age &lt; 30)(users));\n\ngo(users,\n    L.map(u =&gt; u.age),\n    find(n =&gt; n &lt; 30),\n    log);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>인자값으로 받은 <code>iter</code>값을 <code>L.filter</code>로 이터러블객체를 take에 전달하면 take함수에서 실제로 결과를 만들어내기위해 값들을 호출하게 되고, filter condition에 부합하는 값을 찾으면 반환하여 전달 후 구조분해하여 반환한다.</li>\n<li>지연된 평가를 사용하였기에 filter 부분에서 모든 값을 다 condition과 비교하며 비교후 완성된 값을 반환하는게 아니라 generator 호출을 계속 시도하여 filter condition과 비교하며 부합된 값을 찾는데 <code>take(1)</code>이기에 하나의 값을 찾는 순간 로직은 종료되며, 만일, users의 목록이 1000만개인데 10만개쯤에서 결과를 찾는다면 그 뒤 990만번의 불필요한 연산을 막을 수 있다.</li>\n</ul>\n<h2>L.map, L.filter로 map과 filter 만들기</h2>\n<ul>\n<li>L.map과 take(Infinity)을 활용하여 map 구현하기</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const map = curry((f, iter) =&gt; go(\n\titer,\n\tL.map(f),\n\ttake(Infinity)\n));\n\nlog(map(a =&gt; a + 10, L.range(4)));</code>\n        </deckgo-highlight-code>\n<p>pipe를 이용하면 더 간결하게 작성할 수 있다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const map = curry(pipe(L.map, take(Infinity)));\n\nlog(map(a =&gt; a + 10, L.range(4)));</code>\n        </deckgo-highlight-code>\n<ul>\n<li>L.filter와 take(Infinity)을 활용하여 filter구현하기</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const filter = curry(pipe(L.filter, take(Infinity)));\n\nlog(filter(a =&gt; a % 2, range(4)));</code>\n        </deckgo-highlight-code>\n<ul>\n<li>take(Infinity) 공통 함수로 작성</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const takeAll = take(Infinity);\n\nconst map = curry(pipe(L.map, takeAll));\nconst filter = curry(pipe(L.filter, takeAll));</code>\n        </deckgo-highlight-code>\n<h2>L.flatten, flatten</h2>\n<blockquote>\n<p><strong>flatten</strong>: 여러가지 depth를 가진 이터레이터 객체를 평탄화해서 펼친 후 반환해주는 함수</p>\n<p>여러 depth를 가진 배열을 일차원 배열로 만들어주는 것과 유사하다.</p>\n</blockquote>\n<ul>\n<li>L.flattten 생성하기</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">L.flatten = function *(iter) {\n\tfor (const a of iter) {\n\t\tif (isIterator(a)) for (const b of a) yield b;\n\t\telse yield a;\n\t}\n}\n\nconst it = L.flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]]);\nlog([...it]);   // 전체 배열 리턴\nlog(it.next());</code>\n        </deckgo-highlight-code>\n<p>📌  <code>yield *iterable</code> 은 <code>for (const val of iterable) yield val;</code> 와 같다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">L.flatten = function *(iter) {\n  for (const a of iter) {\n    if (isIterable(a)) yield *a;\n    else yield a;\n  }\n};</code>\n        </deckgo-highlight-code>\n<ul>\n<li>flatten 생성하기 (L.flatten, takeAll)\n<ul>\n<li>이전에 만든 지연성 함수를 결과를 도출해내는 함수(take, reduce)를 통해 즉시평가가 가능하게 합니다.</li>\n</ul>\n</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const flatten = pipe(L.flatten, takeAll);\nlog(flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]]));</code>\n        </deckgo-highlight-code>\n<ul>\n<li>take 적용</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">log(take(6, L.flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]])));</code>\n        </deckgo-highlight-code>\n<h3><strong><strong>L.deepFlat</strong></strong></h3>\n<p>: 만일 깊은 Iterable을 모두 펼치고 싶다면 아래와 같이 <code>L.deepFlat</code>을 구현하여 사용할 수 있다. <code>L.deepFlat</code>은 깊은 Iterable을 펼쳐준다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">L.deepFlat = function *f(iter) {\n  for (const a of iter) {\n    if (isIterable(a)) yield *f(a);\n    else yield a;\n  }\n};\n\nlog([...L.deepFlat([1, [2, [3, 4], [[5]]]])]);\n// [1, 2, 3, 4, 5];</code>\n        </deckgo-highlight-code>\n<h2>L.flatMap</h2>\n<ul>\n<li>\n<p>조건을 이용해서 배열의 값을 변경할 수 있다는 점이 flatten과 다르다.</p>\n</li>\n<li>\n<p>L.flatMapr 구현</p>\n</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">L.flatMap = curry(pipe(L.map, L.flatten));\n\nvar it = L.flatMap(a =&gt; a, [[1, 2], [3, 4], [5, 6, 7]]);\nlog([...it]);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>flatMap 구현</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const flatMap = curry(pipe(L.map, flatten));\n\nlog(flatMap(a =&gt; a, [[1, 2], [3, 4], [5, 6, 7]]));</code>\n        </deckgo-highlight-code>\n<ul>\n<li>응용</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">log(flatMap(L.range, map(a =&gt; a + 1, [1, 2, 3])));\n\nvar it = L.flatMap(L.range, map(a =&gt; a + 1, [1, 2, 3]));\nlog(it.next());\nlog(it.next());\n\nlog(take(3, L.flatMap(L.range, map(a =&gt; a + 1, [1, 2, 3]))));</code>\n        </deckgo-highlight-code>\n<h2>2차원 배열 다루기</h2>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const arr = [\n\t[1, 2],\n\t[3, 4, 5],\n\t[6, 7, 8],\n\t[9, 10]\n];\n\ngo(\n\tL.flatten,\n\tL.filter(a =&gt; a % 2),\n\tL.map(a =&gt; a * a),\n\ttake(3),\n\treduce(add)\n)</code>\n        </deckgo-highlight-code>\n<h2>지연성 / 이터러블 중심의 실무적인 코드</h2>\n<h3>문제1. 모든 유저의 가족들 중 미성년자의 이름을 3개만 반환하라.</h3>\n<h2>함수형 프로그래밍이란 ?</h2>\n<p>≒ <strong>이터러블 중심 프로그래밍</strong></p>\n<blockquote>\n<p>조합되어있는 함수에 맞는 데이터를 구성하는 것이다.</p>\n</blockquote>\n<p>⁉️  객체지향 프로그래밍은 데이터에 따라 맞는 함수를 구성하는 것이다.</p>","frontmatter":{"title":"지연성 2","date":"2022년 9월 19일 오후 12:58","categories":["JavaScript"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVQoz62STQrCMBCFc/8T2PoPilJXuhBciGBSq9UKik1jjKioeIwnpAhSEmmLi4HMY+Zj3kxIUvPxzyAmkVeZ8W2rKQT85CaASSO2Ig1xGWKHplrd13kWnoVaJxStAM+ZxG18wGMqcJ9wXEd7vKjCZbgDd2gxy6IZ4NRbQ3ZDKC+C6m8gOyucB1sc28v8O/y2rO26LAV6EZLGAnFlrjXbbksfpdCVfzXZQLmAZT72G1NKhQql3TCnAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/c55503120d6af4960fd8b4f300bbbbc3/fdc73/delayedness2.png","srcSet":"/static/c55503120d6af4960fd8b4f300bbbbc3/3d9cb/delayedness2.png 183w,\n/static/c55503120d6af4960fd8b4f300bbbbc3/e9c2e/delayedness2.png 365w,\n/static/c55503120d6af4960fd8b4f300bbbbc3/fdc73/delayedness2.png 730w,\n/static/c55503120d6af4960fd8b4f300bbbbc3/f1fe2/delayedness2.png 1460w","sizes":"(min-width: 730px) 730px, 100vw"},"sources":[{"srcSet":"/static/c55503120d6af4960fd8b4f300bbbbc3/80a11/delayedness2.webp 183w,\n/static/c55503120d6af4960fd8b4f300bbbbc3/2e3bd/delayedness2.webp 365w,\n/static/c55503120d6af4960fd8b4f300bbbbc3/e25d7/delayedness2.webp 730w,\n/static/c55503120d6af4960fd8b4f300bbbbc3/49049/delayedness2.webp 1460w","type":"image/webp","sizes":"(min-width: 730px) 730px, 100vw"}]},"width":730,"height":382}}}},"timeToRead":4}}]}},"pageContext":{"slug":"/javascript/지연성 2/"}},
    "staticQueryHashes": ["3764592887"]}