{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/javascript/지연성 1/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2>range와 느긋한 L.range</h2>\n<h3>range함수</h3>\n<ul>\n<li>limit를 인자로 받아 그 크기만큼 배열을 반환하는 함수</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const add = (a, b) =&gt; a + b;\n\nconst range = (l) =&gt; {\n\tlet i = -1;\n\tlet res = [];\n\twhile (++i &lt; l) {\n\t\tres.push(i);\n\t}\n\n\treturn res;\n};\n\nconst list = range(4);\n\nreduce(add, list);</code>\n        </deckgo-highlight-code>\n<h3>느긋한 L.range 함수</h3>\n<p>: 즉시 실행해서 배열의 형태를 만드는 것이 아니라, iterator가 순회할 때 <strong>그 때!</strong> 하나씩 만들어짐(=평가가됨).</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const add = (a, b) =&gt; a + b;\n\nconst L = {};\nL.range = function *(l) {\n\tlet i = -1;\n\twhile (++i &lt; l) {\n\t\tyield i;\n\t}\n};\n\nconst list = L.range(4);   \n\nreduce(add, list);   // iterator가 출력됨</code>\n        </deckgo-highlight-code>\n<h3>! 차이점</h3>\n<p>일반 range함수는 함수 호출 시점에 배열을 만든 후 순회하면서 이터레이터를 생성하지만, 느긋한 L.range함수는 함수 호출시점에는 실제 값이 대입되지 않는다.</p>\n<p>L.range함수는 이터레이터의 내부를 순회할 때마다 하나씩 값을 만드는 방식이기 때문에 <strong>성능적으로 훨씬 효율적이다.</strong></p>\n<p>특히, 배열의 길이가 길거나, 무한 수열 등을 사용하는 경우 성능적인 이득을 더 많이 볼 수 있다.</p>\n<h3>range와 느긋한 L.range 성능 비교 해보기</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function test(name, time, f) {\n\tconsole.time(name);\n\twhile(time--) f();\n\tconsole.timeEnd(name);\n}\n\n// test(&#39;range&#39;, 10, () =&gt; reduce(add, range(1000000)));\n// test(&#39;L.range&#39;, 10, () =&gt; reduce(add, L.range(1000000)));</code>\n        </deckgo-highlight-code>\n<h2>take</h2>\n<ul>\n<li>Iterator에서 원하는 갯수만큼의 값을 얻어오는 함수.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const take = (l, iter) =&gt; {\n\tlet res = [];\n\tfor (const a of iter) {\n\t\tres.push(a);\n\t\tif (res.length === l) return res;\n\t}\n\treturn res;\n}\n\ntake(5, L.range(1000000))  // 5개만 만들기 때문에 훨씬 성능적으로 유리함.</code>\n        </deckgo-highlight-code>\n<h2>이터러블 중심 프로그래밍에서의 지연 평가 (Lazy Evaluation)</h2>\n<ul>\n<li>제때 계산법: 평가가 필요할 때까지 미루다가 평가가 이루어져야할 때 평가하여 성능적으로 유리하게 구현</li>\n<li>느긋한 계산법</li>\n<li>제너레이터/이터레이터 프로토콜을 기반으로 구현된다.</li>\n</ul>\n<h2>L.map</h2>\n<p>제너레이터/이터레이터기반의 지연성을 가진 L.map을 구현한다.</p>\n<p>실제 next로 실행하기 전까지는 준비!만 하고 있는 함수라고 생각하면 된다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">L.map = function *(f, iter) {\n\tfor (const a of iter) yield f(a);\n}\n\nconst it = L.map(a =&gt; a + 10, [1, 2, 3]);\nit.next();   // next를 통해서 평가하는 만큼만 생성/실행함.</code>\n        </deckgo-highlight-code>\n<h2>L.filter</h2>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">L.filter = function *(f, iter) {\n\tfor (const a of iter) if(f(a)) yield a;\n}\n\nconst it = L.filter(a =&gt; a % 10, [1, 2, 3, 4]);\nit.next();   // { value: 1, done: false }\nit.next();   // { value: 3, done: false }</code>\n        </deckgo-highlight-code>\n<h2>map, filter 계열 함수들이 가지는 결합 법칙</h2>\n<ul>\n<li>사용하는 데이터가 무엇이든지, 사용하는 보조 함수가 순수 함수라면 무엇이든지 아래와 같이 결합한다면 둘다 결과가 같다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">[[mapping, mapping], [filtering, filtering], [mapping, mapping]]\n=\n[[mapping, filtering, mapping], [mapping, filtering, mapping]]</code>\n        </deckgo-highlight-code>","frontmatter":{"title":"지연성 1","date":"2022년 9월 18일 오후 8:44","categories":["JavaScript"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAr0lEQVQoz62S/QqCMBTF9/7vkFZYFFipmZGoBEYhRNADNJfru4c40UKI2sJJf4xth3t/3HPvJa1xjn8eIhObHpW+VTFawPIvA8g0ogoqIYbzutt+DtOlX/BPqLLCTsCQbm4IV2fM11fE2QXB4oTl9g4/PcJwNS1bEwY7KtAPCwwTDjvi6M32GCUHdKeseg/fLT/tmh4VwEHMhe2GsxOaqre1h6I15V9JKlAlYJ3FfgD8B4Ev+KhIYAAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/865805186c93bf0e4e25783300795bd8/fdc73/delayedness1.png","srcSet":"/static/865805186c93bf0e4e25783300795bd8/3d9cb/delayedness1.png 183w,\n/static/865805186c93bf0e4e25783300795bd8/e9c2e/delayedness1.png 365w,\n/static/865805186c93bf0e4e25783300795bd8/fdc73/delayedness1.png 730w,\n/static/865805186c93bf0e4e25783300795bd8/f1fe2/delayedness1.png 1460w","sizes":"(min-width: 730px) 730px, 100vw"},"sources":[{"srcSet":"/static/865805186c93bf0e4e25783300795bd8/80a11/delayedness1.webp 183w,\n/static/865805186c93bf0e4e25783300795bd8/2e3bd/delayedness1.webp 365w,\n/static/865805186c93bf0e4e25783300795bd8/e25d7/delayedness1.webp 730w,\n/static/865805186c93bf0e4e25783300795bd8/49049/delayedness1.webp 1460w","type":"image/webp","sizes":"(min-width: 730px) 730px, 100vw"}]},"width":730,"height":382}}}},"timeToRead":2}}]}},"pageContext":{"slug":"/javascript/지연성 1/"}},
    "staticQueryHashes": ["3764592887"]}