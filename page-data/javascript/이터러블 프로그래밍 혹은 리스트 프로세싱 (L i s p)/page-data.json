{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/javascript/이터러블 프로그래밍 혹은 리스트 프로세싱 (L i s p)/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p>함수형 프로그래밍은 리습 프로그래밍, 이터러블 프로그래밍이라고도 불린다.</p>\n<p>여기서는 <a href=\"https://github.com/marpple/FxJS\" target=\"_blank\" rel=\"nofollow\">FxJS</a> 를 import하여  <code>_, L, C</code> 등의 함수로 함수형 프로그래밍을 해본다.</p>\n<p>예제를 통해 함수형으로 프로그래밍을 알아보자.</p>\n<h2>홀수 n개 더하기</h2>\n<ul>\n<li>홀수 n개의 제곱의 합을 구하는 함수를 구현해보자.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function f1(limit, list) {\n\tlet acc = 0;\n\tfor (a of list) {\n\t\tif (a % 2) {\n\t\t\tconst b = a * a;\n\t\t\tacc += b;\n\t\t}\n\t\tif (--limit == 0) break;\n\t}\n}\n\nf1(3, [1 ,2 ,3, 4, 5, 6, 7, 8, 9, 10]);</code>\n        </deckgo-highlight-code>\n<h2>if를 filter로</h2>\n<p>if문으로 순회하는 로직은 filter로 추상화 할 수 있다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function f1(limit, list) {\n\tlet acc = 0;\n\tfor (const a of L.filter(a =&gt; a % 2, list)) {\n\t\tconst b = a * a;\n\t\tacc += b;\n\t\tif (--limit == 0) break;\n\t}\n}\n\nf1(3, [1 ,2 ,3, 4, 5, 6, 7, 8, 9, 10]);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>for문이 실행되는 횟수가 줄어들기 때문에 성능적인 이점도 가질 수 있다.</li>\n</ul>\n<h2>값 변화 후 변수 할당을 map으로</h2>\n<p>map을 활용하여 순회하는 배열의 값을 변경하고 a에 변수를 할당한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function f1(limit, list) {\n\tlet acc = 0;\n\tfor (const a of L.map(a =&gt; a * a, L.filter(a =&gt; a % 2, list))) {\n\t\t// const b = a * a;\n\t\tacc += a;\n\t\tif (--limit == 0) break;\n\t}\n}\n\nf1(3, [1 ,2 ,3, 4, 5, 6, 7, 8, 9, 10]);</code>\n        </deckgo-highlight-code>\n<h2>break를 take로</h2>\n<p>take를 활용하여 break 대신 순회 횟수를 제한할 수 있다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function f1(limit, list) {\n\tlet acc = 0;\n\tfor (const a of L.take(limit, L.map(a =&gt; a * a, L.filter(a =&gt; a % 2, list)))) {\n\t\tacc += a;\n\t\t// if (--limit == 0) break;\n\t}\n}\n\nf1(3, [1 ,2 ,3, 4, 5, 6, 7, 8, 9, 10]);</code>\n        </deckgo-highlight-code>\n<p>‼️ 간단한 로직이었지만 이전에 구현해 놨던 L.map, L.filter, L.take 함수를 이용하여 모두 모듈화 가능했다. 명령형으로 작성된 코드를 함수형으로 구현할 수 있다.</p>\n<h2>축약 및 합산을 reduce로</h2>\n<ul>\n<li>주어진 배열에서 홀수 3개를 제곱한 총합을 반환는 예제이다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const add = (a, b) =&gt; a + b;\n\nfunction f2(limit, list) {\n\tconsole.log(\n\t\t_.reduce(add,\n\t\t\tL.take(limit,\n\t\t\t\tL.map(a =&gt; a * a, \n\t\t\t\t\tL.filter(a =&gt; a % 2, list)))));\n}\n\nf1(3, [1 ,2 ,3, 4, 5, 6, 7, 8, 9, 10]);</code>\n        </deckgo-highlight-code>\n<p><code>go</code> 함수를 활용해서 조금 더 직관적으로 읽기 편하도록 구현할 수 있다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function f2(limit, list) {\n\t_.go(list,\n\t\tL.filter(a =&gt; a % 2),\n\t\tL.map(a =&gt; a * a),\n\t\tL.take(limit),\n\t\t_.reduce(add),\n\t\tconsole.log\n\t);\n}</code>\n        </deckgo-highlight-code>\n<h2>while을 range로</h2>\n<p>어떤 구간을 얼만큼 반복하고 싶을 때 사용하는 while 이터러블 프로그래밍 관점에서는 range 함수라고 볼 수 있다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function f3(end) {\n\tlet i = 1;\n\twhile (i &lt; end) {\n\t\tconsole.log(i);\n\t\ti += 2;\n\t}\n}\n\nf3(10);</code>\n        </deckgo-highlight-code>\n<p>range만큼 어떤 행위들을 할 것이다. 라고 명시한다고 생각하면됨.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function f3(end) {\n\t_.each(console.log, L.range(1, end, 2));   // range(start, stop, step)\n}</code>\n        </deckgo-highlight-code>\n<h2>효과를 each로 구분</h2>\n<p>each라는 함수를 사용하면 함수 내부에는 반드시 부수적인 효과, 이펙트가 있다는 것을 표현한다.</p>\n<p>each함수 호출 이후에도 리턴하는 배열이 동일하기 때문에 순회하면서 배열 요소를 변경해준다는 것을 의미.ㅎ</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function f4(end) {\n\t_.go(\n\t\tL.range(1, end, 2),\n\t\t_.each(console.log)\n\t)\n}</code>\n        </deckgo-highlight-code>\n<h2>예제 - 1</h2>\n<h3>추억의 별 그리기</h3>\n<ul>\n<li>출력 결과</li>\n</ul>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">*\n**\n***\n****\n*****</code>\n        </deckgo-highlight-code>\n<ul>\n<li>먼저 range함수로 1 ~ 5 값을 가진 1차원 배열을 만든다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">_.go(\n\tL.range(1, 6),\n\tconsole.log\n);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>map을 순회하면서 range 길이만큼 배열로 리턴해준다.</li>\n<li>range는 인자의 길이만큼 숫자를 배열로 생성해서 리턴해주는 함수이다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">_.go(\n\tL.range(1, 6),\n\tL.map(L.range),\n\tconsole.log\n);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>숫자로 구성된 요소들을 <code>*</code> 문자로 변경해준다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">_.go(\n\tL.range(1, 6),\n\tL.map(L.range),\n\tL.map(L.map(_ =&gt; &#39;*&#39;)),\n\tconsole.log\n);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>내부 배열들의 <code>*</code>  문자를 reduce를 이용해서 하나의 문자로 합쳐준다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">_.go(\n\tL.range(1, 6),\n\tL.map(L.range),\n\tL.map(L.map(_ =&gt; &#39;*&#39;)),\n\tL.map(_.reduce((a, b) =&gt; `${a}${b}`)),\n\tconsole.log\n);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>배열을 줄바꿈 문자(<code>\\n</code>) 기준으로 reduce를 이용해 한번 더 합쳐준다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">_.go(\n\tL.range(1, 6),\n  L.map(L.range),\n  L.map(L.map(_ =&gt; &#39;*&#39;)),\n  L.map(_.reduce((a, b) =&gt; `${a}${b}`)),\n  _.reduce((a, b) =&gt; `${a}\\n${b}`),\n  console.log\n);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>코드를 더 읽기 쉽게 리팩토링 해보면 아래와 로직이 완성된다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const join = sep =&gt; _.reduce((a, b) =&gt; `${a}${sel}${b}`);\n\n_.go(\n\tL.range(1, 6),\n\tL.map(L.range),\n\tL.map(L.map(_ =&gt; &#39;*&#39;)),\n\tL.map(join(a, b)),\n\tL.map(join(a, b, &#39;\\n&#39;)),\n\tconsole.log\n);</code>\n        </deckgo-highlight-code>\n<h2>예제 - 2</h2>\n<h3>추억의 구구단</h3>\n<ul>\n<li>출력 결과</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">2 x 1 = 2\n2 x 2 = 4\n2 x 3 = 6\n2 x 4 = 8\n2 x 5 = 10\n2 x 6 = 12\n2 x 7 = 14\n2 x 8 = 16\n2 x 9 = 18\n\n3 x 1 = 3\n3 x 2 = 6\n3 x 3 = 9\n...</code>\n        </deckgo-highlight-code>\n<ul>\n<li>먼저 2 ~ 9 값을 가진 배열을 생성한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">_.go(\n\tL.range(2, 10),\n\tconsole.log\n);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>map을 순회하면서 1 ~ 9 범위를 가진 내부 배열을 생성한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">_.go(\n\tL.range(2, 10),\n\tL.map(a =&gt; _.go(\n\t\tL.range(1, 10)\n\t)),\n\tconsole.log\n);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>a와 i 값을 이용해 구구단 형식으로 출력해준다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">_.go(\n\tL.range(2, 10),\n\tL.map(a =&gt; _.go(\n\t\tL.range(1, 10),\n\t\tL.map(i =&gt; `${a} x ${i} = ${a * i}`),\n\t)),\n\tconsole.log\n);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>내부 배열을 위에서 구현한 <code>join</code> 함수를 이용하여 <code>\\n</code> 기준으로 합쳐준다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">_.go(\n\tL.range(2, 10),\n\tL.map(a =&gt; _.go(\n\t\tL.range(1, 10),\n\t\tL.map(i =&gt; `${a} x ${i} = ${a * i}`),\n\t\tjoin(&#39;\\n&#39;)\n\t)),\n\tconsole.log\n);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>전체 배열을 <code>\\n\\n</code> 기준으로 합쳐준다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">_.go(\n\tL.range(2, 10),\n  L.map(a =&gt; _.go(\n\t  L.range(1, 10),\n\t  L.map(i =&gt; `${a} x ${i} = ${a * i}`),\n\t  join(&#39;\\n&#39;)\n  )),\n  join(&#39;\\n\\n&#39;),\n  console.log\n);</code>\n        </deckgo-highlight-code>","frontmatter":{"title":"이터러블 프로그래밍 혹은 리스트 프로세싱 (L i s p)","date":"2022년 9월 22일 오후 1:59","categories":["JavaScript"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAy0lEQVQoz62SaQrCMBCFc/9TuItL7ZK6tHZxQRQUvEbTJC4neJJgodaIuPx4TGaYfPMmhLisiX+KmIpO1jCeX/V8BCxyE8BUI+8go6ymo8dasLP6WzgpJ0WzukhZB4fLGptTiP1lid05wUpOcbxusZBjPajqXsUHh8qFz7qgrI1p3kcsXMy5jUi4CPkIAR9q2IwPdI+n1Xp2qKRcTfIeUkGxkL6GhdxCIihi4SHgFiLh6JhKiuReU0PKT2Bc+RsZV/7l/z2t/C2ger4B4lmKJs2wCa8AAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/ae8e7627874d5cd51d6321a0f655e85a/fdc73/iterable-programming-or-lisp.png","srcSet":"/static/ae8e7627874d5cd51d6321a0f655e85a/3d9cb/iterable-programming-or-lisp.png 183w,\n/static/ae8e7627874d5cd51d6321a0f655e85a/e9c2e/iterable-programming-or-lisp.png 365w,\n/static/ae8e7627874d5cd51d6321a0f655e85a/fdc73/iterable-programming-or-lisp.png 730w,\n/static/ae8e7627874d5cd51d6321a0f655e85a/f1fe2/iterable-programming-or-lisp.png 1460w","sizes":"(min-width: 730px) 730px, 100vw"},"sources":[{"srcSet":"/static/ae8e7627874d5cd51d6321a0f655e85a/80a11/iterable-programming-or-lisp.webp 183w,\n/static/ae8e7627874d5cd51d6321a0f655e85a/2e3bd/iterable-programming-or-lisp.webp 365w,\n/static/ae8e7627874d5cd51d6321a0f655e85a/e25d7/iterable-programming-or-lisp.webp 730w,\n/static/ae8e7627874d5cd51d6321a0f655e85a/49049/iterable-programming-or-lisp.webp 1460w","type":"image/webp","sizes":"(min-width: 730px) 730px, 100vw"}]},"width":730,"height":382}}}},"timeToRead":4}}]}},"pageContext":{"slug":"/javascript/이터러블 프로그래밍 혹은 리스트 프로세싱 (L i s p)/"}},
    "staticQueryHashes": ["3764592887"]}