{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/javascript/ES6에서의 순회와 이터러블 이터레이터 프로토콜/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2>기존과 달라진 ES6에서의 리스트 순회</h2>\n<p>: for i++ 의 index 방식에서 for…of 의 iterator방식으로 변경되었다.</p>\n<ul>\n<li>기존 리스트 순회</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const list = [1, 2, 3];\nfor( var i = 0; i&lt; list.length; i++){\n\tlog(list[i]);\n}\n\n// 유사 배열 순회\nconst str = &#39;abc&#39;;\nfor( var i = 0; i&lt; str.length; i++){\n\tlog(str[i]);\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>변경된 리스트 순회</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">for (const a of list) {\n\tlog(a);\n}\n\nfor (const a of str) {\n\tlog(a);\n}</code>\n        </deckgo-highlight-code>\n<h2>Array, Set, Map를 통해 알아보기</h2>\n<ul>\n<li>Array를 통해 알아보기</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const arr = [1, 2, 3];\nfor (const a of arr) log(a);   // 1, 2, 3\n</code>\n        </deckgo-highlight-code>\n<ul>\n<li>Set을 통해 알아보기</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const set = new Set([1, 2, 3]);\nfor (const a of set) log(a);   // 1, 2, 3</code>\n        </deckgo-highlight-code>\n<ul>\n<li>Map을 통해 알아보기</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const map = new Map([[&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]]);\nfor (const a of map) log(a);   // 1, 2, 3</code>\n        </deckgo-highlight-code>\n<p>: 해당 함수를 통해 반환되는 값들도 Iterator형태이기 때문에 <code>map.values(), map.keys(), map.entries()</code>도 정상동작한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const map = new Map([[&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]]);\nfor (const a of map.keys()) log(a);\nfor (const a of map.values()) log(a);\nfor (const a of map.entries()) log(a);</code>\n        </deckgo-highlight-code>\n<h2>이터러블/이터레이터 프로토콜</h2>\n<ul>\n<li>이터러블: 이터레이터를 리턴하는 <code>[Symbol.iterator]()</code> 를 가진 값.</li>\n<li>이터레이터: <code>{ value, done }</code> 객체를 리턴하는 <code>next()</code> 를 가진 값.</li>\n<li>이터러블/이터레이터 프로토콜: 이터러블을 <code>for…of</code>, 전개 연산자 등과 함께 동작 하도록 한 규약.</li>\n</ul>\n<h3>사용자 정의 이터러블</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const iterable = {\n\t[Symbol.iterator]() {\n\t\tlet i = 3;\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\treturn i === 0 ? { done: true } : { value: i--, done: false };\n\t\t\t},\n\t\t\t[Symbol.iterator]() { return this; }  // 자기 자신을 반환하는 로직\n\t\t}\n\t}\n};\n\nlet iterator = iterable[Symbol.iterator]();\nfor (const a of iterable) log(a);\nfor (const a of iterator) log(a);   // 위의 로직을 추가해주어야 오류 없이 동작한다.\n\nconst arr = [1, 2, 3];\nlet iter2 = arr[Symbol.iterator]();\nlog(iter2[Symbol.iterator]() == iter2);</code>\n        </deckgo-highlight-code>\n<p>📌  <strong>잘 만든 이터러블이란 ?!</strong></p>\n<ul>\n<li>이터러블을 만들어서 순회할 때 잘 동작한다.</li>\n<li>일부 진행한 이후에는 진행된 결과 이후의 값들로 진행이 된다.</li>\n<li>자기 자신을 반환하는 <code>Symbol.iterator</code>를 가지고 있어야 한다.</li>\n</ul>\n<p>DOM도 Iterator를 통해 순회가 가능하다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">for (const a of document.querySelectAll(&#39;*&#39;)) log(a);</code>\n        </deckgo-highlight-code>\n<h2>전개 연산자 (=나머지 연산자)</h2>\n<ul>\n<li>전개 연산자도 이터러블/이터레이터 프로토콜을 따른다.</li>\n<li>iterator를 null로 변경하면 에러가 발생한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const a = [1, 2];\na[Symbol.iterator] = null; \nlog([...a, ...[3,4]);   // Uncaught TypeError: a is not iterable\n\nconsole.log([...a, ...[3, 4]]);   // [1, 2, 3, 4]</code>\n        </deckgo-highlight-code>","frontmatter":{"title":"ES6에서의 순회와 이터러블:이터레이터 프로토콜","date":"2022년 9월 18일 오후 2:34","categories":["JavaScript"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAy0lEQVQoz62STQrCMBCFe/8TaLS0CCr+14ULF+Ki1YjaPwRRvEHSpOoFntBaqTTSKi6GmXmZ+ZgH0fiqiX+GphKZ01DWn2a+Ama9CqDStDIIs+vPNx3MIUp4vtfywgviEHBq4H5e4nqY4XZa4HacIw6nuF9sxIEFZtfe4FkuXkgN8LWBaNOC9AYQ+x6E20/zrgsZTBBt28kMpyb4Wi9e+AJSE9IfJ0vC7aXAJ0z6o6SW3hDSTfU4tCB2HTCblFmuGqSC5R9CaflfH/sBTROVrEWdtWoAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/df282fd3c07ccb334a462a20b4eae3bc/fdc73/es6%20iterator%20protocol.png","srcSet":"/static/df282fd3c07ccb334a462a20b4eae3bc/3d9cb/es6%20iterator%20protocol.png 183w,\n/static/df282fd3c07ccb334a462a20b4eae3bc/e9c2e/es6%20iterator%20protocol.png 365w,\n/static/df282fd3c07ccb334a462a20b4eae3bc/fdc73/es6%20iterator%20protocol.png 730w,\n/static/df282fd3c07ccb334a462a20b4eae3bc/f1fe2/es6%20iterator%20protocol.png 1460w","sizes":"(min-width: 730px) 730px, 100vw"},"sources":[{"srcSet":"/static/df282fd3c07ccb334a462a20b4eae3bc/80a11/es6%20iterator%20protocol.webp 183w,\n/static/df282fd3c07ccb334a462a20b4eae3bc/2e3bd/es6%20iterator%20protocol.webp 365w,\n/static/df282fd3c07ccb334a462a20b4eae3bc/e25d7/es6%20iterator%20protocol.webp 730w,\n/static/df282fd3c07ccb334a462a20b4eae3bc/49049/es6%20iterator%20protocol.webp 1460w","type":"image/webp","sizes":"(min-width: 730px) 730px, 100vw"}]},"width":730,"height":382}}}},"timeToRead":2}}]}},"pageContext":{"slug":"/javascript/ES6에서의 순회와 이터러블 이터레이터 프로토콜/"}},
    "staticQueryHashes": ["3764592887"]}