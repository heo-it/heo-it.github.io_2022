{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/javascript/비동기 동시성 프로그래밍 2/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2>지연평가 + Promise - L.map, map, take</h2>\n<p>이전에 이터러블을 다루는 <code>L.map, map, take</code>는 기본적으로 동기적으로 돌아가는 상황에서만 정상적인 동작을 하도록 구현하다. 해당 함수들도 <code>reduce, pipe, go</code>처럼 비동기상황에서도 동작하도록 리팩토링 해보자 !</p>\n<h3>예제</h3>\n<p>: go함수의 인자가 Promise객체인 경우</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go([Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)],\n\tL.map(a =&gt; a + 10),\n\ttake(2),\n\tlog\n);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>먼저 L.map에서 Promise를 받을 수 있도록 변경한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">L.map = curry(function *(f, iter) {\n\tfor (const a of iter) \n\t\tyield go1(a, f);\n});\n\n// [Promise, Promise] Promise 객체가 반환된다.</code>\n        </deckgo-highlight-code>\n<ul>\n<li>그런 다음 take 함수에서 Promise내부의 값을 꺼내어 반환하는 로직이 필요하다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const take = curry((l, iter) =&gt; {\n\tlet res = [];\n\titer = iter[Symbol.iterator]();\n\tlet cur;\n\twhile (!(cur = iter.next()).done) {\n\t\tconst a = cur.value;\n\t\tif (a instanceof Promise) a.then(a =&gt; {\n\t\t\tres.push(a);\n\t\t\tif (res.length === l) return res;\n\t\t\t// else -&gt; while\n\t\t});\n\t\tres.push(a);\n\t\tif (res.length === l) return res;\n\t}\n\treturn res;\n});</code>\n        </deckgo-highlight-code>\n<p><code>a</code>가 Promise일 경우 then하도록 구현해주는데, 이 때 <code>l(limit)</code> 보다 추출된 배열의 길이가 작을 경우 다시 while문을 다시 도는 로직이 필요하다. 이것은 다시 함수 안으로 들어와야한다는 것이고 필요한 부분을 잘라서 재귀함수 호출 방식으로 처리하면 된다.</p>\n<ul>\n<li>재귀호출에 필요한 로직을 유명함수에 넣어주고 호출해 준다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const take = curry((l, iter) =&gt; {\n\tlet res = [];\n\titer = iter[Symbol.iterator]();\n\n\treturn function recur(){\n\t\tlet cur;\n\t\t\twhile (!(cur = iter.next()).done) {\n\t\t\t\tconst a = cur.value;\n\t\t\t\tif (a instanceof Promise) a.then(\n\t\t\t\t\ta =&gt; ((res.push(a), res).length === l ? res : recur();\n\t\t\t\t\t// res.push(a);\n\t\t\t\t\t// return res.length === l ? res : recur();\n\t\t\t\t));\n\t\t\t\tres.push(a);\n\t\t\t\tif (res.length === l) return res;\n\t\t\t}\n\t\t\treturn res;\n\t}();\n});</code>\n        </deckgo-highlight-code>\n<p>로직을 조금 더 간결하게 구성하였다.</p>\n<ul>\n<li>아래와 같이 map에 들어가는 함수가 Promise인 경우에도 정상적으로 동작한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go(\n  [1, 2, 3],\n  map(a =&gt; Promise.resolve(a + 10)),\n  log);</code>\n        </deckgo-highlight-code>\n<h2>Kleisli Composition - L.filter, filter, nop, take</h2>\n<p>filter에서 지연평가와 비동기성을 함께 지원하려면 Kleisli Composition을 적용해야한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go([1, 2, 3, 4, 5, 6],\n    L.map(a =&gt; Promise.resolve(a * a)),\n    L.filter(a =&gt; a % 2),\n\t\ttake(2),\n    log\n);   // []</code>\n        </deckgo-highlight-code>\n<p>현재 이 코드는 정상적으로 값이 출력되지 않는다. filter로 넘어오는 값이 Promise이기 때문에 <code>Promise % 2</code> 를 수행하는데 문제가 생기기 때문이다.</p>\n<ul>\n<li>이 부분을 해결하기 위해서 먼저 <code>L.filter</code> 에서 Promise를 받을 수 있도록 변경한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">L.filter = curry(function *(f, iter) {\n\tfor (const a of iter) {\n\t\tconst b = go1(a, f);\n\t\tif(b) yield a;\t\n\t}\n});\n// [Promise, Promise]</code>\n        </deckgo-highlight-code>\n<ul>\n<li>위의 L.filter는 Promise를 반환하기 때문에 Promise내부의 값을 꺼내어 반환하는 로직이 필요하다. 이때 <strong>nop</strong>을 이용한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const nop = Symbol(&#39;nop&#39;);\n\nL.filter = curry(function *(f, iter) {\n\tfor (const a of iter) {\n\t\tconst b = go1(a. f);   // Promise\n\t\tif (b instanceof Promise) yield b.then(b =&gt; b ? a : Promise.reject(nop));\n\t\telse if (b) yield a;\n\t}\n});</code>\n        </deckgo-highlight-code>\n<p>b가 Promise인지 검사를 한 후에 then을 통해 b인자를 풀어주는데 b가 true이면 a를 반환하고 아닌 경우 아무 행동도 하지 않도록 구현해주어야 한다.</p>\n<p>하지만 위의 로직에서 <code>yield</code> 통해 generated되서 전달되기 때문에 다음 함수의 인자값으로 들어가지 않도록 해야한다. 이때 사용하는 것이 <strong>Kleisli Composition</strong>이다.</p>\n<p>위의 코드에서 b의 값이 없거나 <code>false</code>인 경우 <code>reject</code> 을 해주는데 그냥 reject 을 해주는 경우 에러 발생 reject으로 오해할 수 있기 때문에 <strong>nop</strong>이라는 구분자를 만들어 처리해준다.</p>\n<blockquote>\n<p>참고: nop 구분자를 Symbol로 선언한 이유는 Symbol값이라도 객체의 프로퍼티 값으로 사용할 수 있는 Symbol값은 유일한 값이므로 Symbol 값을 키로 갖는 프로퍼티는 다른 어떠한 프로퍼티와도 충돌하지 않기 때문에 약속된 구분자로 사용할 수 있어 사용한다.</p>\n</blockquote>\n<p><a href=\"https://poiemaweb.com/es6-symbol\" target=\"_blank\" rel=\"nofollow\">Symbol | PoiemaWeb</a></p>\n<ul>\n<li>추가적으로 <code>take function</code> 부분에서도 reject에 대한 처리를 해줘야한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const take = curry((l, iter) =&gt; {\n\tlet res = [];\n\titer = iter[Symbol.iterator]();\n\n\treturn function recur(){\n\t\tlet cur;\n\t\t\twhile (!(cur = iter.next()).done) {\n\t\t\t\tconst a = cur.value;\n\t\t\t\tif (a instanceof Promise) {\n\t\t\t\t\ta.then(a =&gt; ((res.push(a), res).length === l ? res : recur()))\n\t\t\t\t\t\t.catch(e =&gt; e === nop ? recur() : Promise.reject(e));\n\t\t\t\t}\n\t\t\t\tres.push(a);\n\t\t\t\tif (res.length === l) return res;\n\t\t\t}\n\t\t\treturn res;\n\t}();\n});</code>\n        </deckgo-highlight-code>\n<p>take에서 reject을 통해 catch가 잡혔을 때 해당 paramater가 nop일 경우 무시하고 다음 함수를 평가하도록 해야한다.</p>\n<h2>reduce에서 nop지원</h2>\n<p>reduce도 nop을 이용해서 지연성과 비동기성을 지원하도록 만들어보자.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go([1, 2, 3, 4, 5],\n    L.map(a =&gt; Promise.resolve(a * a)),\n    L.filter(a =&gt; Promise.resolve(a % 2)),\n    reduce(add),\n\t\tlog);\n// 1[object Promise][object Promise][object Promise] Uncaught (in promise) Symbol(nop)</code>\n        </deckgo-highlight-code>\n<p>현재 이 코드는 Promise를 지원하지 않는다.</p>\n<ul>\n<li>기존에 구현한 reduce</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const reduce = curry((f, acc, iter) =&gt; {\n    if (!iter) {\n        iter = acc[Symbol.iterator]();\n        acc = iter.next().value;\n    }\n    return go1(acc, function recur(acc) {\n        for (const a of iter) {\n            acc = f(acc, a);\n            if(acc instanceof Promise) return acc.then(recur);\n        }\n        return acc;\n    });\n});</code>\n        </deckgo-highlight-code>\n<ul>\n<li>\n<p>reduce내부의 for내부에서 nop을 캐치하는 부분과 a를 풀어주는 부분을 만들면 된다.  저 두 부분만 해결하면 되기에 모듈로 만들어서 호출하도록 구현한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const reduceF = (acc, a, f) =&gt; \n\ta instanceof Promise ? a.then(a =&gt; f(acc, a), e =&gt; e === nop ? acc : Promise.reject(e)) : f(acc, a);\n\nconst reduce = curry((f, acc, iter) =&gt; {\n    if (!iter) {\n\t    iter = acc[Symbol.iterator]();\n      acc = iter.next().value;\n    }\n    return go1(acc, function recur(acc) {\n        for (const a of iter) {\n            acc = reduceF(acc, a, f)\n            if(acc instanceof Promise) return acc.then(recur);\n        }\n        return acc;\n    });\n});</code>\n        </deckgo-highlight-code>\n<ul>\n<li><code>reduceF</code>라는 함수를 만들어 a가 Promisel일 경우 then을 통해 a를 꺼내어 <code>f(acc, a)</code>를 수행하도록 해주고 <code>reject(nop)</code>인 경우 acc를 그대로 반환한다.</li>\n<li>Promise가 아닌 경우 즉시 <code>f(acc, a)</code> 를 실행한다.</li>\n</ul>\n</li>\n</ul>\n<h3>reduce 모듈화</h3>\n<p>reduce에서 iter가 없는 경우에 대한 처리를 하는 로직을 모듈화 할 수 있다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const head = iter =&gt; go1(take(1, iter), ([h]) =&gt; h);\n\nconst reduce = curry((f, acc, iter) =&gt; {\n    if (!iter) return reduce(f, head(iter = acc[Symbol.iterator]()), iter);\n\n    return go1(acc, function recur(acc) {\n        for (const a of iter) {\n            acc = reduceF(acc, a, f)\n            if(acc instanceof Promise) return acc.then(recur);\n        }\n        return acc;\n    });\n});</code>\n        </deckgo-highlight-code>\n<ul>\n<li>head라는 함수를 만들어 인자값으로 받은 iter에서 첫번째 인자값을 take로 가져온다. 그 뒤 take는 배열값을 반환하기 때문에 구조분해로 내부값을 꺼내 반환한다.</li>\n<li>head함수로 reduce 함수에서 iter가 없는 경우 재귀적으로 인자를 만들어 다시 호출해 정상동작하도록 한다.</li>\n</ul>\n<h2>지연 평가 + Promise의 효율성</h2>\n<p>비동기 상황이 함수 대기열에 등록되어있는 경우 전체적인 성능 부분에서 많은 딜레이가 생길 수 있다. 지연 평가를 함으로써 이 부분의 성능적인 이점을 얻을 수 있다.</p>\n<ul>\n<li>비동기 상황이 함수 대기열에 등록되어있는 경우 - 지연평가</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go([1, 2, 3, 4, 5, 6, 7, 8],\n    L.map(a =&gt; {\n        log(a);\n        return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(a * a), 1000))\n    }),\n    L.filter(a =&gt; {\n        log(a);\n        return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(a % 2), 1000))\n    }),\n    take(2),\n    // reduce(add),\n    log\n)</code>\n        </deckgo-highlight-code>\n<p>위와 같이 지연평가를 하는 <code>L.map, L.filter</code> 를 사용하는 경우 필요한 값을 다 구했다면, 그 다음 내용들을 수행되지 않기 때문에 성능적인 이점을 많이 얻을 수 있다.</p>\n<h2>지연된 함수열을 병렬적으로 평가하기 - C.reduce, C.take [1]</h2>\n<p>현재까지 구현된 <code>go</code> 함수의 동작 방식은 첫번 째 인자인 배열의 첫번째 값(<code>1</code>)부터 <code>L.map, L.filter</code> 을 지나면서 대기하다가, <code>reduce</code> 에 리턴된 값을 전달하면서 완료되고, 이와 동일한 과정을 첫번 째 인자의 배열 순서대로(<code>1 → 2 → 3 → 4 → 5</code>) 반복하면서 진행되고 있다.</p>\n<p>결국 reduce함수에서는 앞에 나열된 함수들이 처리 해줄 때까지 기다리고 있는 셈인데, 모든 인자를 한번에 실행시키면 더 빠르게 결과를 만들 수 있을것이다.</p>\n<ul>\n<li><code>C.reduce</code> 를 생성하여 reduce에 모든 값들을 전부 나열해서 보내어 모든 함수를 동시에 실행시키면 좀 더 빠르게 결과를 만들 수 있다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const C = {};\n\nC.reduce = curry((f, acc, iter) =&gt; iter ?\n\treduce(f, acc, [...iter]) :\n\treduce(f, [...acc]));</code>\n        </deckgo-highlight-code>\n<h2>지연된 함수열을 병렬적으로 평가하기 - C.reduce, C.take [2]</h2>\n<h3>문제</h3>\n<p>다음과 같이 여러 함수열을 비동기 상황으로 사용하다 보면 여러 Promise에서 예측하기 어려운 다양한 에러가 발생할 수 있다.</p>\n<p>JavaScript 특성상 Promise에서 reject은 호출된 시점에서 catch를 해주어야 한다. 이후 원하는 시점에서 이전에 발생한 reject에 대해 처리해주려고 해도 방법이 없다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go([1, 2, 3, 4, 5, 6, 7, 8, 9],\n\tL.map(a =&gt; delay1000(a * a)),\n  L.filter(a =&gt; delay1000(a % 2)),\n  L.map(a =&gt; delay1000(a * a)),\n  C.reduce(add),\n\tlog);\n\n// Uncaught (in promise) Symbol(nop)\n// Uncaught (in promise) Symbol(nop)\n// Uncaught (in promise) Symbol(nop)</code>\n        </deckgo-highlight-code>\n<ul>\n<li>위의 상황과 같이 예기치 않은 reject로 에러 로그가 출력될 경우를 대비하기 위한 처리가 필요하다.</li>\n</ul>\n<h3>해결방법</h3>\n<p>이 때, Promise reject이 발생하기 전에 catch를 해준다면 이후 에러 로그를 출력하지 않도록 할 수 있다.</p>\n<p>현재 Promise reject에 대해 당장은 아무일도 하지 않도록 처리해주고, 이후 원하는 시점에서 해당 오류에 대해 catch할 수 있게 된다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function noop() {}  // 아무일도 하지 않는 함수\nconst catchNoop = arr =&gt;\n\t(arr.forEach(a =&gt; a instanceof Promise ? a.catch(noop) : a), arr);   // 받은 array를 그대로 리턴하도록 구현\n\nC.reduce = curry((f, acc, iter) =&gt; {\n\tconst iter2 = catchNoop(iter ? [...iter] : [...acc]);   // reduce를 실행하기 전에 미리 에러 catch를 해놓음\n\n\treturn iter ?\n\t\treduce(f, acc, iter2) :\n\t\treduce(f, iter2));\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>\n<p><code>noop</code> 함수를 선언해서 아무일도 하지 않는 함수를 정의한다.</p>\n</li>\n<li>\n<p><code>catchNoop</code> 함수에서 각 Promise에 임시적으로 catch를 한다. catch를 선언하지 않거나, reject뒤에 즉시 실행 시키지 않을 경우에는 원하는 시점에 catch를 해줄 수 있다.</p>\n</li>\n<li>\n<p>C.reduce 를 조금더 간결하게 리팩토링 하였다.</p>\n</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">C.reduce = curry((f, acc, iter) =&gt; iter ? \n\treduce(f, acc, catchNoop([...iter])) : \n\treduce(f, catchNoop([...acc])));</code>\n        </deckgo-highlight-code>\n<h3>C.take</h3>\n<p>C.take함수도 동일한 방법으로 구현할 수 있다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">C.take = curry((l, iter) =&gt; take(l, catchNoop([...iter])));</code>\n        </deckgo-highlight-code>\n<h2>즉시 병렬적으로 평가하기 - C.map, C.filter</h2>\n<p>지금까지는 평가, 결론을 짓는 <code>reduce, take</code>함수에서 여러개의 대기 함수열들을 병렬적으로 실행하는 방식을 구현해보았다.</p>\n<p>여기서는 특정 함수라인에서만 병렬적으로 활용하고 싶은 경우를 위한 <code>C.map, C.filter</code> 를 구현해보겠다.</p>\n<ul>\n<li>먼저 <code>takeAll</code> 함수를 만들어준다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">C.takeAll = C.take(Infinity);</code>\n        </deckgo-highlight-code>\n<ul>\n<li><code>L.map</code>과 <code>C.takeAll</code>을 이용하여 <code>C.map</code>을 생성한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">C.map = curry(pipe(L.map, C.takeAll));</code>\n        </deckgo-highlight-code>\n<ul>\n<li><code>L.filter</code>과 <code>C.takeAll</code>을 이용하여 <code>C.filter</code> 생성한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">C.filter = curry(pipe(L.filter, C.takeAll));</code>\n        </deckgo-highlight-code>\n<ul>\n<li>아래와 같이 사용가능하다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">C.map(a =&gt; delay1000(a * a), [1, 2, 3, 4]).then(log);\nC.filter(a =&gt; delay1000(a % 2), [1, 2, 3, 4]).then(log);</code>\n        </deckgo-highlight-code>\n<h2>즉시, 지연, Promise, 병렬적 조합하기</h2>\n<p>처음 구현한 map, filter, reduce, take 등의 함수를 부하 정도나, 엄격함의 정도등을 고려한 상황에 맞춰 알맞게 선택하여 사용하면 된다.</p>\n<ul>\n<li>즉시 함수 사용 (=가장 엄격하게 평가함)</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go([1, 2, 3, 4, 5, 6, 7, 8, 9],\n\tmap(a =&gt; delay1000(a * a)),\n  filter(a =&gt; delay1000(a % 2)),\n  map(a =&gt; delay1000(a + 1)),\n  take(2),\n\tlog);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>지연 함수 사용</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go([1, 2, 3, 4, 5, 6, 7, 8, 9],\n\tL.map(a =&gt; delay1000(a * a)),\n  L.filter(a =&gt; delay1000(a % 2)),\n  L.map(a =&gt; delay1000(a + 1)),\n  take(2),\n\tlog);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>병렬 함수 사용</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go([1, 2, 3, 4, 5, 6, 7, 8, 9],\n\tC.map(a =&gt; delay1000(a * a)),\n  C.filter(a =&gt; delay1000(a % 2)),\n  C.map(a =&gt; delay1000(a + 1)),\n  C.take(2),\n\tlog);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>복합적으로 구성하여 사용</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go([1, 2, 3, 4, 5, 6, 7, 8, 9],\n\tL.map(a =&gt; delay1000(a * a)),\n  L.filter(a =&gt; delay1000(a % 2)),\n  L.map(a =&gt; delay1000(a + 1)),\n  C.take(2),\n\tlog);</code>\n        </deckgo-highlight-code>\n<p>📌  <strong>결론: 위와 같이 함수들을 적절하게 필요한 상황에 따라 활용하여 사용하면 된다.</strong></p>","frontmatter":{"title":"비동기: 동시성 프로그래밍 2","date":"2022년 9월 20일 오후 2:49","categories":["JavaScript"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAApElEQVQoz62S3Q7CIAyFef8n8C/CNt3ADdgiM9nijHKx1zoGkt1MuEC9aEqb8pWWQ7J9jn8aCSXZLgueYzVJwCUOAUI5EitaIMcN9T4/FKBb9gFfQ6MvPNEz7MNiMCOe9xemYULf3TDbGUb3vlHSyCWr0NYdZCWhuILkCnXZ4KoNeCHSduhGc5f0pfUg5xsHFto3ESnA9Q5jFvsskiKJr2Xzi7Df2HhA2gD7hqAAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/a0f47757fd4f84af6bcd4a5c9a57527e/fdc73/async_concurrency_2.png","srcSet":"/static/a0f47757fd4f84af6bcd4a5c9a57527e/3d9cb/async_concurrency_2.png 183w,\n/static/a0f47757fd4f84af6bcd4a5c9a57527e/e9c2e/async_concurrency_2.png 365w,\n/static/a0f47757fd4f84af6bcd4a5c9a57527e/fdc73/async_concurrency_2.png 730w,\n/static/a0f47757fd4f84af6bcd4a5c9a57527e/f1fe2/async_concurrency_2.png 1460w","sizes":"(min-width: 730px) 730px, 100vw"},"sources":[{"srcSet":"/static/a0f47757fd4f84af6bcd4a5c9a57527e/80a11/async_concurrency_2.webp 183w,\n/static/a0f47757fd4f84af6bcd4a5c9a57527e/2e3bd/async_concurrency_2.webp 365w,\n/static/a0f47757fd4f84af6bcd4a5c9a57527e/e25d7/async_concurrency_2.webp 730w,\n/static/a0f47757fd4f84af6bcd4a5c9a57527e/49049/async_concurrency_2.webp 1460w","type":"image/webp","sizes":"(min-width: 730px) 730px, 100vw"}]},"width":730,"height":382}}}},"timeToRead":8}}]}},"pageContext":{"slug":"/javascript/비동기 동시성 프로그래밍 2/"}},
    "staticQueryHashes": ["3764592887"]}