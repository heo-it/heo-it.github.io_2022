{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/javascript/비동기 동시성 프로그래밍 1/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2>Callback과 Promise</h2>\n<h3>Callback</h3>\n<p>함수의 인자값으로 함수를 받아 해당 함수에 인자값을 전달하면서 로직을 수행한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function add10(a, callback) {\n\tsetTimeout(() =&gt; callback(a + 10), 100);\n}\n\nadd10(5, res = &gt; {\n\tlog(res);\n});   // 15</code>\n        </deckgo-highlight-code>\n<h3>Promise</h3>\n<p>Promise객체를 만들어 return 해준다는 점이 callback함수와 가장 큰 차이이다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function add20(a) {\n\treturn new Promise(resolve =&gt; setTimeout(() =&gt; resolve(a + 20), 100));\n}\n\nadd20(5)\n\t.then(log);</code>\n        </deckgo-highlight-code>\n<h3>차이점</h3>\n<ol>\n<li>연속적으로 실행하는 경우 depth 차이가 발생함</li>\n<li>callback은 함수를 인자로 받아 수행하는 반면, Promise는 Promise 객체를 반환한다. <strong>로직이 수행되는 주체가 다르다.</strong></li>\n</ol>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">add10(5, res =&gt; {\n\tadd10(res, res =&gt; {\n\t\tadd10(res, res =&gt; {\n\t\t\tlog(res);\n\t\t});\n\t});\n})\n\nadd20(5)\n\t.then(add20)\n  .then(add20)\n\t.then(log);</code>\n        </deckgo-highlight-code>\n<h2>비동기를 값으로 만드는 Promise</h2>\n<p>Promise와 callback의 가장 큰 차이점은 Promise는 비동기 상황을 일급 값으로 처리한다는 점이다. 대기, 성공, 실패를 다루는 일급 값으로 이루어져 있다는 점이 가장 다르고 중요하다.</p>\n<p>Promise는 Promise로 만들어진 인스턴스를 반환하여 대기, 성공, 실패를 다루는 일급 값으로 이루어져 있는데, 이는 로직을 끝내는 것을 코드나 컨택스트로만 다루는게 아니라 대기중이라는 값을 생성한다는 점에서 Callback과 가장 큰 차이점이다.</p>\n<p>값을 만들어서, 리턴을 하고 있기 때문에 그 이후에 떨어지는 결과로 내가 하고 싶은 일을 추가적으로 할 수 있다는 점이 가장 큰 장점이다 !!</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function add10(a, callback) {\n  setTimeout(() =&gt; callback(a + 10), 100);\n}\n\nvar a = add10(5, res =&gt; {\n  add10(res, res =&gt; {\n    add10(res, res =&gt; {\n        log(res);\n    });\n  });\n});\n\nlog(a);   // undefined\n\nfunction add20(a) {\n  return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(a + 20), 100));\n}\n\nvar b = add20(5)\n  .then(add20)\n  .then(add20)\n  .then(log);   // Promise {&lt;pending&gt;}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>callback의 결과를 담은 a와 다르게 Promise의 반환객체를 담은 b의 출력값을 보면 Promise 객체를 보여주는데, 이는 callback에서는 반환값에 중점을 두는게 아닌 코드적인 상황(<code>setTimeout</code>)이나 Context(<code>Callback</code>)만 중점으로 둔다는 것이다.</li>\n<li>Promise는 즉시 Promise객체를 반환한다는 특징이 있는데, 이는 callback과는 다르게 Context 함수 로직에 이어지는 로직을 then을 통해 추가적으로 이어갈 수 있다는 것이다. 즉, Promise의 경우 비동기적으로 이루어진 상황에 대해서 값으로 다룬다는 것이고, 일급값이라는 의미가 되며 다른 곳에서 해당 일급값을 재사용할 수 있다는 의미에서 연속성을 가질 수 있다는 장점이 있다.</li>\n</ul>\n<h2>값으로서의 Promise 활용</h2>\n<p>Promise가 비동기 상황을 일급값으로 다룬다는 점을 활용한 여러가지 예제이다.</p>\n<h3>예제</h3>\n<ul>\n<li>아래와 같이 a라는 인자값을 f에 들어온 인자값 함수에 전달해 로직을 수행하는 go1 함수가 있다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const go1 = (a, f) =&gt; f(a);\nconst add5 = a =&gt; a + 5;\n\nconst delay100 = a = new Promise(resolve =&gt;\n\tsetTimeout(() =&gt; resolve(a), 100));\n\nlog(go1(10, add5));   // 15\nlog(go1(Promise.resolve(10), add5));   // [object Promise]5\nlog(go1(delay100(10), add5);   // [object Promise]5</code>\n        </deckgo-highlight-code>\n<p>go1은 a인자가 동기적으로 유효한 값인 경우에만 정상 동작하는 함수이다. a인자가 Promise객체이거나, 비동기적으로 함수의 결과가 지연되는 경우 정상적인 결과를 출력하지 못한다.</p>\n<ul>\n<li>go1 함수에서 a인자값이 Promise인지 평가한 후 then을 수행하도록 추가한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const go1 = (a, f) =&gt; a instanceof Promise ? a.then(f) : f(a);\n\nvar r2 = go1(delay100(10), add5);\nr2.then(log);   // 15</code>\n        </deckgo-highlight-code>\n<ul>\n<li>비동기, 동기적으로 호출된 두 함수를 같은 형태를 가지도록 구현할 수 있다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const n1 = 10;\ngo1(go1(n1, add5), log);\n\nconst n2 = delay100(10);\ngo1(go1(n2, add5), log);</code>\n        </deckgo-highlight-code>\n<h2>합성 관점에서의 Promise와 모나드</h2>\n<p>Promise는 비동기 상황에서 함수 합성을 하기 위한 모나드라고 할 수 있다. (이 얘기를 처음 들었을 때 도저히 이해하기 어려웠는데, 아래 내용들을 이해하다보면 딱 맞는 문장이라고 생각한다.)</p>\n<p>자바스크립트는 동적타입언어이자 스크립트 언어이기 때문에 타입에 대해 엄격하지 않기에 모나드, 대수구조의 타입이 잘 붇어나지 않는 경향이 있기 때문에 자바스크립트에서는 모나드를 직접적으로 사용하거나 모나드의 개념을 이용한 사용자 정의 객체를 만들면서 구현하지는 않는다.</p>\n<p>그렇기 때문에 모나드라는 것을 이해하는데 너무 초점을 둘 필요는 없다.</p>\n<p>하지만, 함수형 프로그래밍이나 함수 합성에서 모나드의 개념을 알고 있으면 좀 더 높은 퀄리티의 코드를 작성할 수 있다.</p>\n<h3>모나드란?</h3>\n<p>모나드는 일종의 박스이고 박스안에 값이 들어있다고 볼수 있다. <code>[1]</code></p>\n<p>그리고 이 값을 이용해서 함수 합성들을 안전하게 수행해나가는 것이다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const g = a =&gt; a + 1;\nconst f = a =&gt; a * a;\n\nlog(f(g(1)));   // 4\nlog(f(g()));   // NaN</code>\n        </deckgo-highlight-code>\n<ul>\n<li>인자가 없는 상태로 함수 합성 되는 경우 정상적으로 값이 출력되지 않는다.</li>\n</ul>\n<p>📌  <strong>결론</strong></p>\n<p>함수합성에 사용되는 인자값이 유의미한 값이 아닌 경우 문제가 발생한다는 것인데, 실무에서는 인자값으로 어떤 값이 올 지 모르고 빈값이 올 가능성도 충분하기 때문에 위의 함수합성은 안전하지 않은 함수 합성이다. 이처럼 인자값이 어떤 값이 올 지 모르는 불안한 상황에서 함수 합성을 어떻게 안전하게 할 지 고려하여 나온 것이 <strong>모나드</strong>이다.</p>\n<h3>예제</h3>\n<p>아래와 같이 박스를 가지고 있고, 그 내부에 실제 효과나 연산에 필요한 값을 가지고 있고 이를 통해 함수 합성을 한다. 반환 타입이 Array인걸 볼 수 있는데 타입이 중요한 것은 아니므로 꺼내어주는 것이 좋다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">log([1].map(g).map(f));   // [4]\n[1].map(g).map(f).forEach(a =&gt; log(a)); // 4\n\n[].map(g).map(f).forEach(a =&gt; log(a)); // 결과 없음</code>\n        </deckgo-highlight-code>\n<ul>\n<li>안에 아무런 값이 없어도 어떤 잘못된 출력이나 에러가 발생하지 않는다. 실제 최종 결과 값을 도출해내는 <code>forEach</code> 함수에 도착하기전에 안전하게 종료된다.</li>\n</ul>\n<blockquote>\n<p><strong>모나드</strong>:  x라는 인자값을 a라는 함수에게 전달했을때 a라는 함수가 수행 된 이후 그 값이 바로 b라는 함수에 전달되는 것을 함수 합성이라 하는데, 이러한 함수 합성을 안전하게 수행하도록 하는 것을 모나드라고 하고, 대표적으로 Promise가 있다.</p>\n</blockquote>\n<p>⇒ b(a(x))</p>\n<blockquote>\n</blockquote>\n<h3>Promise는?</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">Promise.resolve(1).then(g).then(f).then(log);   // 4</code>\n        </deckgo-highlight-code>\n<p>Promise는 비동기적으로 일어나는 상황에 대해 안전하게 함수 합성을 하기 위한 도구이다. 지연되어 나오는 값들에 대해서 안전하게 핸들링 하기 위한 도구라고 할 수 있다.</p>\n<h2>Kleisli Composition 관점에서의 Promise</h2>\n<p>Promise는 Kleisli Composition을 지원하는 도구라고 볼 수 있는데, Kleisli Composition 혹은 Kleisli Arrow라고 불리는 함수 합성 방법은 오류가 있을수 있는 상황에서의 함수합성을 안전하게 하는 하나의 규칙이라고 볼 수 있다.</p>\n<p>Kleisli Composition은 들어오는 인자가 잘못되어서 함수에서 오류가 나는 상황이나 정확한 인자가 들어왔더라도 어떤 함수가 의존하고 있는 외부의 상태에 의해서 결과를 전달 할 수 없을 때 이것을 해결하기 위한 함수 합성이라고 볼 수 있다.</p>\n<h3>예제</h3>\n<ul>\n<li>\n<p>유저목록에서 id로 해당 유저를 찾아 이름을 반환하는 로직</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">var users = [\n\t{ id: 1, name: &#39;aa&#39; },\n\t{ id: 2, name: &#39;bb&#39; },\n\t{ id: 3, name: &#39;cc&#39; }\n];\n\nconst getUserById = id =&gt;\tfind(u =&gt; u.id === id, users);\n\nconst f = ({name}) =&gt; name;\nconst g = getUserById;\nconst fg = id =&gt; f(g(id));\n\nconst r = fg(2);\nlog(r);   // bb</code>\n        </deckgo-highlight-code>\n<ul>\n<li>users에서 인자값으로 받은 id와 동일한 user를 찾는 함수 getuserById</li>\n<li>name을 구조분해하여 얻어 반환하는 f</li>\n<li>getuserById를 값으로 취급하는 g</li>\n<li>f와 g를 합성해 users에서 특정 id의 name을 추출해 반환하는 fg</li>\n<li>fg(2);를 호출하면 g(2)가 실행되어 users에서 id가 2인 obj를 꺼내전달하고 ({id:2, name:‘bb})</li>\n</ul>\n<p>f함수에서는 name을 구조분해하여 추출후 반환한다.</p>\n</li>\n</ul>\n<p>여기서 찾고자 하는 id가 현재 user에 없는 4, 5, 6이거나 기존 id들이 외부 상황에 의해 변한다면 오류가 발생한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const r = fg(5); //Uncaught TypeError: Cannot destructure property &#39;name&#39; of &#39;undefined&#39; as it is undefined.\n\nusers.pop();\nusers.pop();\nconst r = fg(2)//Uncaught TypeError: Cannot destructure property &#39;name&#39; of &#39;undefined&#39; as it is undefined.</code>\n        </deckgo-highlight-code>\n<p>잘못된 값 혹은 외부에 변화에 따라 에러가 발생할 수 있는데, 이러한 상황에서 문제가 발생하지 않도록 하는 것을 <strong>Kleisli Arrow</strong>라고 한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const getUserById = id =&gt; find(u =&gt; u.id === id, users)|| Promise.reject(&quot;없어요!&quot;);\nconst fg = id =&gt; Promise.resolve(id).then(g).then(f).catch(a=&gt;a);\nusers.pop();\nusers.pop();\nfg(2).then(log); //없어요!</code>\n        </deckgo-highlight-code>\n<ul>\n<li><code>getUserById</code>의 결과가 없는 경우 <code>Promise</code>객체를 반환하게 되고 <code>fg</code>에서는 해당객체의 <code>reject</code>가 호출되면 <code>catch</code>부분에서 받아서 출력함으로써 에러를 발생하지 않도록 한다.</li>\n</ul>\n<h2>go, pipe, reduce에서 비동기 제어</h2>\n<p>비동기를 다루는 Promise객체를 이용해 go, pipe, reduce함수들에서도 비동기를 값으로 다루는 성직을 이용하여 Promise와 같이 비동기 상황에 놓여져도 잘 대응하는 함수를 만들 수 있다. 또는 Kleisli처럼 중간에 reject가 발생했을 경우에도 대응하는 방법을 적용할 수 있다.</p>\n<h3>예제</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go(1,\n    a =&gt; a + 10,\n\t\ta =&gt; Promise.resolve(a + 100),\n    a =&gt; a + 1000,\n    log\n);   // [object Promise]1000</code>\n        </deckgo-highlight-code>\n<p>위와 같이 <code>a + 100</code> 이 Promise타입으로 바뀌는 경우에 올바르지 않은 값이 출력된다.</p>\n<p>이것은 현재 go함수를 통해 전달되어 실행되는 함수가 reduce인데 여기서 acc가 Promise가 되면서 (<code>f(Promise, a)</code> ) 다음 루프를 도는 경우 에러가 발생한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const go = (...args) =&gt; reduce((a, f) =&gt; f(a), args);\nconst reduce = curry((f, acc, iter) =&gt; {\n    if (!iter) {\n        iter = acc[Symbol.iterator]();\n        acc = iter.next().value;\n    }\n    for (const a of iter) {\n        acc = f(acc, a);\n    }\n    return acc;\n});</code>\n        </deckgo-highlight-code>\n<h3>해결 방법 - 1</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const reduce = curry((f, acc, iter) =&gt; {\n    if (!iter) {\n        iter = acc[Symbol.iterator]();\n        acc = iter.next().value;\n    }\n    for (const a of iter) {\n        acc = acc instanceof Promise ? acc.then(acc =&gt; f(acc,a)) : f(acc, a);\n    }\n    return acc;\n}); // 1111</code>\n        </deckgo-highlight-code>\n<p>Promise인 경우 then을 실행해주는 방법으로 해결해 줄 수 있다. 하지만 Promise를 만나게 되면 그 뒤로는 계속해서 Promise Chaning이 걸리게 되고, 이런 함수 합성이 많은 경우 불 필요한 분기를 타게 되면서 성능 저하가 일어날 수 있다.</p>\n<h3>해결 방법 - 2</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const reduce = curry((f, acc, iter) =&gt; {\n    if (!iter) {\n        iter = acc[Symbol.iterator]();\n        acc = iter.next().value;\n    }\n    return function recur(acc) {\n        for (const a of iter) {\n            acc = f(acc, a);\n            if (acc instanceof Promise) return acc.then(recur);\n        }\n        return acc;\n    }(acc);\n});\n\ngo(1,\n    a =&gt; a + 10,\n    a =&gt; Promise.resolve(a + 100),\n    a =&gt; a + 1000,\n    log\n);   //1111</code>\n        </deckgo-highlight-code>\n<p>재귀를 이용한 방법을 사용한다. 유명함수를 이용해 return값에 <code>recur</code>함수를 선언해서 내부에서 우선 인자값 함수를 실행한 후 해당 값이 Promise이면 <code>acc.then(recure)</code>로 재귀호출을 하여 Promise의 실제 결과 값이 인자로 전달되는 방식이다.</p>\n<h3>보강 - 첫 인자값이 Promise인 경우</h3>\n<p>go에서 사용되는 첫 번째 인자값이 Promise인 경우에는 아직 에러가 발생한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go(Promise.resolve(1),\n\ta =&gt; a + 10,\n\ta =&gt; Promise.resolve(a + 100),\n\ta =&gt; a + 1000,\n\tlog\n);</code>\n        </deckgo-highlight-code>\n<p>위와 같이 첫번째 인자부터 Promise인 경우 reduce의 유명함수 실행시 첫번째 인자를 Promise로 전달하기 때문에 <code>f(acc, a)</code> 에서 오류가 발생한다. 이런 경우 첫번째 인자값이 Promise인 경우 then을 실행하는 <code>go1</code> 함수를 이용하여 처리를 해주어야한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const go1 = (a, f) =&gt; a instanceof Promise ? a.then(f) : f(a);\n\nconst reduce = curry((f, acc, iter) =&gt; {\n    if (!iter) {\n        iter = acc[Symbol.iterator]();\n        acc = iter.next().value;\n    }\n    return go1(acc, function recur(acc) {\n        for (const a of iter) {\n            acc = f(acc, a);\n            if(acc instanceof Promise) return acc.then(recur);\n        }\n        return acc;\n    });\n});\n\ngo(Promise.resolve(1),\n    a=&gt;a+10,\n    a=&gt;Promise.resolve(a+100),\n    a=&gt;a+1000,\n    log\n);//1111</code>\n        </deckgo-highlight-code>\n<h2>Promise.then의 중요한 규칙</h2>\n<ol>\n<li>여러개의 <code>resolve</code>가 중첩되어 있어도 한번의 <code>then</code>으로 꺼내어 볼 수 있다.</li>\n<li>아무리 <code>Promise</code>가 여러개로 중첩되어있어도 가장 내부에 있는 결과값이 도출되어 전달된다.</li>\n</ol>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">Promise.resolve(Promise.resolve(1)).then(function (a) {\n  log(a);\n});\n\nnew Promise(resolve =&gt; resolve(new Promise(resolve =&gt; resolve(1)))).then(log);</code>\n        </deckgo-highlight-code>","frontmatter":{"title":"비동기: 동시성 프로그래밍 1","date":"2022년 9월 19일 오후 8:30","categories":["JavaScript"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAnElEQVQoz62SywrDIBBF/f8fqY/U1NRHQANCQyM0/3SLQjapLmy7uIwOw5lxvEQIjn+K1JKcs+q5VdMFPO41QC1HWkUHhNJLicMgwBj9gJ+hzQmlvCKlhBgjtu2JdX1gWQL2/YUQfIF3PXkcJebZwRgNa02R1nd476HUrW+Hufs0KThnCyjHDM4xN+kCnnfYUuuzSI8lvrbNL8Z+AxaOWti0MvA9AAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/7c66de63c09c9d68757a06b1c956dfda/fdc73/async_concurrency_1.png","srcSet":"/static/7c66de63c09c9d68757a06b1c956dfda/3d9cb/async_concurrency_1.png 183w,\n/static/7c66de63c09c9d68757a06b1c956dfda/e9c2e/async_concurrency_1.png 365w,\n/static/7c66de63c09c9d68757a06b1c956dfda/fdc73/async_concurrency_1.png 730w,\n/static/7c66de63c09c9d68757a06b1c956dfda/f1fe2/async_concurrency_1.png 1460w","sizes":"(min-width: 730px) 730px, 100vw"},"sources":[{"srcSet":"/static/7c66de63c09c9d68757a06b1c956dfda/80a11/async_concurrency_1.webp 183w,\n/static/7c66de63c09c9d68757a06b1c956dfda/2e3bd/async_concurrency_1.webp 365w,\n/static/7c66de63c09c9d68757a06b1c956dfda/e25d7/async_concurrency_1.webp 730w,\n/static/7c66de63c09c9d68757a06b1c956dfda/49049/async_concurrency_1.webp 1460w","type":"image/webp","sizes":"(min-width: 730px) 730px, 100vw"}]},"width":730,"height":382}}}},"timeToRead":7}}]}},"pageContext":{"slug":"/javascript/비동기 동시성 프로그래밍 1/"}},
    "staticQueryHashes": ["3764592887"]}