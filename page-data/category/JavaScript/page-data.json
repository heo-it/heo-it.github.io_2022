{
    "componentChunkName": "component---src-templates-category-template-tsx",
    "path": "/category/JavaScript/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"8336a5a5-f2da-562f-8009-c03aca5d240a","fields":{"slug":"/javascript/ES6 구조분해할당/"},"html":"<h2>1. 배열 분해하기</h2>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">let arr = [&quot;apple&quot;, &quot;banana&quot;];\n\nlet [first, second] = arr;\n\nconsole.log(first);   // apple\nconsole.log(banana);   // banana</code>\n        </deckgo-highlight-code>\n<h3>쉼표를 사용하여 요소 무시하기</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">let [first, , thired] = [&quot;apple&quot;, &quot;banana&quot;, &quot;watermelon&quot;];\n\nconsole.log(first);  // apple\nconsole.log(thired); // watermelon</code>\n        </deckgo-highlight-code>\n<h3>변수 교환 트릭</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">let first = &quot;apple&quot;;\nlet second = &quot;banana&quot;;\n\n[first, second] = [second, first];\n\nconsole.log(first, second);  // banana, apple</code>\n        </deckgo-highlight-code>\n<h3>‘…’로 나머지 요소 가져오기</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">let [first, second, ...rest] = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;];\n\nconsole.log(first);  // &#39;a&#39;\nconsole.log(second); // &#39;b&#39;\nconsole.log(rest);  // [&#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]..</code>\n        </deckgo-highlight-code>\n<h3>기본값</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">let [fisrt = &quot;apple&quot;, second = &quot;banana&quot;] = [&quot;watermelon&quot;];\n\nconsole.log(first);  // watermelon\nconsole.log(second); // banana</code>\n        </deckgo-highlight-code>\n<h2>2. 객체 분해하기</h2>\n<p>객체 분해의 가장 큰 장점은 객체 순서와 상관없이 저장된 값과 상응하는 변수에 할당 된다는 것이다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">let { first, second } = { second: &quot;banana&quot;, first: &quot;apple&quot; };\n\nconsole.log(first, second);  // apple, banana</code>\n        </deckgo-highlight-code>\n<h3>기본값</h3>\n<p>배열과 마찬가지로 선언 시 기본값을 설정할 수 있으며, 표현식 뿐만 아니라 함수 호출을 기본값으로 할당할 수 있다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">let fruits= {\n\tfirst: &quot;apple&quot;\n};\n\nlet { first = prompt(&#39;apple&#39;), second = prompt(&#39;banana&#39;) } = fruits;\n\nconsole.log(first);  // apple\nconsole.log(second)  // prompt창에 입력된 값</code>\n        </deckgo-highlight-code>\n<h3>‘…’로 나머지 요소 가져오기</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">let fruits = {\n\tfirst: &quot;apple&quot;,\n  second: &quot;banana&quot;,\n\tthired: &quot;watermelon&quot;,\n};\n\nlet {first, ...rest} = fruits;\n\nconsole.log(first);        // apple\nconsole.log(rest.second);  // banana\nconsole.log(rest.thired);  // watermelon</code>\n        </deckgo-highlight-code>\n<h2>3. 함수 매개변수</h2>\n<p>함수의 매개변수를 구조 분해하여 받을 수 있다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">let fruits = {\n\tfirst: &quot;apple&quot;,\n  second: &quot;banana&quot;,\n\tthired: &quot;watermelon&quot;,\n};\n\nshowFruits ({ first, second, thired}) =&gt; {\n\talret(first);\n\talret(second);\n\talret(thired);\n}\n\nshowFruits(fruits);</code>\n        </deckgo-highlight-code>","frontmatter":{"title":"ES6 구조분해할당","date":"2022년 1월 26일 오후 4:21","summary":"ES6의 구조 분해 할당 문법에 대해 정리","categories":["JavaScript"]}}},{"node":{"id":"60477ea9-e7e8-5c82-b608-ac9ebefbba99","fields":{"slug":"/javascript/비동기 동시성 프로그래밍 1/"},"html":"<h2>Callback과 Promise</h2>\n<h3>Callback</h3>\n<p>함수의 인자값으로 함수를 받아 해당 함수에 인자값을 전달하면서 로직을 수행한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function add10(a, callback) {\n\tsetTimeout(() =&gt; callback(a + 10), 100);\n}\n\nadd10(5, res = &gt; {\n\tlog(res);\n});   // 15</code>\n        </deckgo-highlight-code>\n<h3>Promise</h3>\n<p>Promise객체를 만들어 return 해준다는 점이 callback함수와 가장 큰 차이이다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function add20(a) {\n\treturn new Promise(resolve =&gt; setTimeout(() =&gt; resolve(a + 20), 100));\n}\n\nadd20(5)\n\t.then(log);</code>\n        </deckgo-highlight-code>\n<h3>차이점</h3>\n<ol>\n<li>연속적으로 실행하는 경우 depth 차이가 발생함</li>\n<li>callback은 함수를 인자로 받아 수행하는 반면, Promise는 Promise 객체를 반환한다. <strong>로직이 수행되는 주체가 다르다.</strong></li>\n</ol>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">add10(5, res =&gt; {\n\tadd10(res, res =&gt; {\n\t\tadd10(res, res =&gt; {\n\t\t\tlog(res);\n\t\t});\n\t});\n})\n\nadd20(5)\n\t.then(add20)\n  .then(add20)\n\t.then(log);</code>\n        </deckgo-highlight-code>\n<h2>비동기를 값으로 만드는 Promise</h2>\n<p>Promise와 callback의 가장 큰 차이점은 Promise는 비동기 상황을 일급 값으로 처리한다는 점이다. 대기, 성공, 실패를 다루는 일급 값으로 이루어져 있다는 점이 가장 다르고 중요하다.</p>\n<p>Promise는 Promise로 만들어진 인스턴스를 반환하여 대기, 성공, 실패를 다루는 일급 값으로 이루어져 있는데, 이는 로직을 끝내는 것을 코드나 컨택스트로만 다루는게 아니라 대기중이라는 값을 생성한다는 점에서 Callback과 가장 큰 차이점이다.</p>\n<p>값을 만들어서, 리턴을 하고 있기 때문에 그 이후에 떨어지는 결과로 내가 하고 싶은 일을 추가적으로 할 수 있다는 점이 가장 큰 장점이다 !!</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function add10(a, callback) {\n  setTimeout(() =&gt; callback(a + 10), 100);\n}\n\nvar a = add10(5, res =&gt; {\n  add10(res, res =&gt; {\n    add10(res, res =&gt; {\n        log(res);\n    });\n  });\n});\n\nlog(a);   // undefined\n\nfunction add20(a) {\n  return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(a + 20), 100));\n}\n\nvar b = add20(5)\n  .then(add20)\n  .then(add20)\n  .then(log);   // Promise {&lt;pending&gt;}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>callback의 결과를 담은 a와 다르게 Promise의 반환객체를 담은 b의 출력값을 보면 Promise 객체를 보여주는데, 이는 callback에서는 반환값에 중점을 두는게 아닌 코드적인 상황(<code>setTimeout</code>)이나 Context(<code>Callback</code>)만 중점으로 둔다는 것이다.</li>\n<li>Promise는 즉시 Promise객체를 반환한다는 특징이 있는데, 이는 callback과는 다르게 Context 함수 로직에 이어지는 로직을 then을 통해 추가적으로 이어갈 수 있다는 것이다. 즉, Promise의 경우 비동기적으로 이루어진 상황에 대해서 값으로 다룬다는 것이고, 일급값이라는 의미가 되며 다른 곳에서 해당 일급값을 재사용할 수 있다는 의미에서 연속성을 가질 수 있다는 장점이 있다.</li>\n</ul>\n<h2>값으로서의 Promise 활용</h2>\n<p>Promise가 비동기 상황을 일급값으로 다룬다는 점을 활용한 여러가지 예제이다.</p>\n<h3>예제</h3>\n<ul>\n<li>아래와 같이 a라는 인자값을 f에 들어온 인자값 함수에 전달해 로직을 수행하는 go1 함수가 있다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const go1 = (a, f) =&gt; f(a);\nconst add5 = a =&gt; a + 5;\n\nconst delay100 = a = new Promise(resolve =&gt;\n\tsetTimeout(() =&gt; resolve(a), 100));\n\nlog(go1(10, add5));   // 15\nlog(go1(Promise.resolve(10), add5));   // [object Promise]5\nlog(go1(delay100(10), add5);   // [object Promise]5</code>\n        </deckgo-highlight-code>\n<p>go1은 a인자가 동기적으로 유효한 값인 경우에만 정상 동작하는 함수이다. a인자가 Promise객체이거나, 비동기적으로 함수의 결과가 지연되는 경우 정상적인 결과를 출력하지 못한다.</p>\n<ul>\n<li>go1 함수에서 a인자값이 Promise인지 평가한 후 then을 수행하도록 추가한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const go1 = (a, f) =&gt; a instanceof Promise ? a.then(f) : f(a);\n\nvar r2 = go1(delay100(10), add5);\nr2.then(log);   // 15</code>\n        </deckgo-highlight-code>\n<ul>\n<li>비동기, 동기적으로 호출된 두 함수를 같은 형태를 가지도록 구현할 수 있다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const n1 = 10;\ngo1(go1(n1, add5), log);\n\nconst n2 = delay100(10);\ngo1(go1(n2, add5), log);</code>\n        </deckgo-highlight-code>\n<h2>합성 관점에서의 Promise와 모나드</h2>\n<p>Promise는 비동기 상황에서 함수 합성을 하기 위한 모나드라고 할 수 있다. (이 얘기를 처음 들었을 때 도저히 이해하기 어려웠는데, 아래 내용들을 이해하다보면 딱 맞는 문장이라고 생각한다.)</p>\n<p>자바스크립트는 동적타입언어이자 스크립트 언어이기 때문에 타입에 대해 엄격하지 않기에 모나드, 대수구조의 타입이 잘 붇어나지 않는 경향이 있기 때문에 자바스크립트에서는 모나드를 직접적으로 사용하거나 모나드의 개념을 이용한 사용자 정의 객체를 만들면서 구현하지는 않는다.</p>\n<p>그렇기 때문에 모나드라는 것을 이해하는데 너무 초점을 둘 필요는 없다.</p>\n<p>하지만, 함수형 프로그래밍이나 함수 합성에서 모나드의 개념을 알고 있으면 좀 더 높은 퀄리티의 코드를 작성할 수 있다.</p>\n<h3>모나드란?</h3>\n<p>모나드는 일종의 박스이고 박스안에 값이 들어있다고 볼수 있다. <code>[1]</code></p>\n<p>그리고 이 값을 이용해서 함수 합성들을 안전하게 수행해나가는 것이다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const g = a =&gt; a + 1;\nconst f = a =&gt; a * a;\n\nlog(f(g(1)));   // 4\nlog(f(g()));   // NaN</code>\n        </deckgo-highlight-code>\n<ul>\n<li>인자가 없는 상태로 함수 합성 되는 경우 정상적으로 값이 출력되지 않는다.</li>\n</ul>\n<p>📌  <strong>결론</strong></p>\n<p>함수합성에 사용되는 인자값이 유의미한 값이 아닌 경우 문제가 발생한다는 것인데, 실무에서는 인자값으로 어떤 값이 올 지 모르고 빈값이 올 가능성도 충분하기 때문에 위의 함수합성은 안전하지 않은 함수 합성이다. 이처럼 인자값이 어떤 값이 올 지 모르는 불안한 상황에서 함수 합성을 어떻게 안전하게 할 지 고려하여 나온 것이 <strong>모나드</strong>이다.</p>\n<h3>예제</h3>\n<p>아래와 같이 박스를 가지고 있고, 그 내부에 실제 효과나 연산에 필요한 값을 가지고 있고 이를 통해 함수 합성을 한다. 반환 타입이 Array인걸 볼 수 있는데 타입이 중요한 것은 아니므로 꺼내어주는 것이 좋다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">log([1].map(g).map(f));   // [4]\n[1].map(g).map(f).forEach(a =&gt; log(a)); // 4\n\n[].map(g).map(f).forEach(a =&gt; log(a)); // 결과 없음</code>\n        </deckgo-highlight-code>\n<ul>\n<li>안에 아무런 값이 없어도 어떤 잘못된 출력이나 에러가 발생하지 않는다. 실제 최종 결과 값을 도출해내는 <code>forEach</code> 함수에 도착하기전에 안전하게 종료된다.</li>\n</ul>\n<blockquote>\n<p><strong>모나드</strong>:  x라는 인자값을 a라는 함수에게 전달했을때 a라는 함수가 수행 된 이후 그 값이 바로 b라는 함수에 전달되는 것을 함수 합성이라 하는데, 이러한 함수 합성을 안전하게 수행하도록 하는 것을 모나드라고 하고, 대표적으로 Promise가 있다.</p>\n</blockquote>\n<p>⇒ b(a(x))</p>\n<blockquote>\n</blockquote>\n<h3>Promise는?</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">Promise.resolve(1).then(g).then(f).then(log);   // 4</code>\n        </deckgo-highlight-code>\n<p>Promise는 비동기적으로 일어나는 상황에 대해 안전하게 함수 합성을 하기 위한 도구이다. 지연되어 나오는 값들에 대해서 안전하게 핸들링 하기 위한 도구라고 할 수 있다.</p>\n<h2>Kleisli Composition 관점에서의 Promise</h2>\n<p>Promise는 Kleisli Composition을 지원하는 도구라고 볼 수 있는데, Kleisli Composition 혹은 Kleisli Arrow라고 불리는 함수 합성 방법은 오류가 있을수 있는 상황에서의 함수합성을 안전하게 하는 하나의 규칙이라고 볼 수 있다.</p>\n<p>Kleisli Composition은 들어오는 인자가 잘못되어서 함수에서 오류가 나는 상황이나 정확한 인자가 들어왔더라도 어떤 함수가 의존하고 있는 외부의 상태에 의해서 결과를 전달 할 수 없을 때 이것을 해결하기 위한 함수 합성이라고 볼 수 있다.</p>\n<h3>예제</h3>\n<ul>\n<li>\n<p>유저목록에서 id로 해당 유저를 찾아 이름을 반환하는 로직</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">var users = [\n\t{ id: 1, name: &#39;aa&#39; },\n\t{ id: 2, name: &#39;bb&#39; },\n\t{ id: 3, name: &#39;cc&#39; }\n];\n\nconst getUserById = id =&gt;\tfind(u =&gt; u.id === id, users);\n\nconst f = ({name}) =&gt; name;\nconst g = getUserById;\nconst fg = id =&gt; f(g(id));\n\nconst r = fg(2);\nlog(r);   // bb</code>\n        </deckgo-highlight-code>\n<ul>\n<li>users에서 인자값으로 받은 id와 동일한 user를 찾는 함수 getuserById</li>\n<li>name을 구조분해하여 얻어 반환하는 f</li>\n<li>getuserById를 값으로 취급하는 g</li>\n<li>f와 g를 합성해 users에서 특정 id의 name을 추출해 반환하는 fg</li>\n<li>fg(2);를 호출하면 g(2)가 실행되어 users에서 id가 2인 obj를 꺼내전달하고 ({id:2, name:‘bb})</li>\n</ul>\n<p>f함수에서는 name을 구조분해하여 추출후 반환한다.</p>\n</li>\n</ul>\n<p>여기서 찾고자 하는 id가 현재 user에 없는 4, 5, 6이거나 기존 id들이 외부 상황에 의해 변한다면 오류가 발생한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const r = fg(5); //Uncaught TypeError: Cannot destructure property &#39;name&#39; of &#39;undefined&#39; as it is undefined.\n\nusers.pop();\nusers.pop();\nconst r = fg(2)//Uncaught TypeError: Cannot destructure property &#39;name&#39; of &#39;undefined&#39; as it is undefined.</code>\n        </deckgo-highlight-code>\n<p>잘못된 값 혹은 외부에 변화에 따라 에러가 발생할 수 있는데, 이러한 상황에서 문제가 발생하지 않도록 하는 것을 <strong>Kleisli Arrow</strong>라고 한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const getUserById = id =&gt; find(u =&gt; u.id === id, users)|| Promise.reject(&quot;없어요!&quot;);\nconst fg = id =&gt; Promise.resolve(id).then(g).then(f).catch(a=&gt;a);\nusers.pop();\nusers.pop();\nfg(2).then(log); //없어요!</code>\n        </deckgo-highlight-code>\n<ul>\n<li><code>getUserById</code>의 결과가 없는 경우 <code>Promise</code>객체를 반환하게 되고 <code>fg</code>에서는 해당객체의 <code>reject</code>가 호출되면 <code>catch</code>부분에서 받아서 출력함으로써 에러를 발생하지 않도록 한다.</li>\n</ul>\n<h2>go, pipe, reduce에서 비동기 제어</h2>\n<p>비동기를 다루는 Promise객체를 이용해 go, pipe, reduce함수들에서도 비동기를 값으로 다루는 성직을 이용하여 Promise와 같이 비동기 상황에 놓여져도 잘 대응하는 함수를 만들 수 있다. 또는 Kleisli처럼 중간에 reject가 발생했을 경우에도 대응하는 방법을 적용할 수 있다.</p>\n<h3>예제</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go(1,\n    a =&gt; a + 10,\n\t\ta =&gt; Promise.resolve(a + 100),\n    a =&gt; a + 1000,\n    log\n);   // [object Promise]1000</code>\n        </deckgo-highlight-code>\n<p>위와 같이 <code>a + 100</code> 이 Promise타입으로 바뀌는 경우에 올바르지 않은 값이 출력된다.</p>\n<p>이것은 현재 go함수를 통해 전달되어 실행되는 함수가 reduce인데 여기서 acc가 Promise가 되면서 (<code>f(Promise, a)</code> ) 다음 루프를 도는 경우 에러가 발생한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const go = (...args) =&gt; reduce((a, f) =&gt; f(a), args);\nconst reduce = curry((f, acc, iter) =&gt; {\n    if (!iter) {\n        iter = acc[Symbol.iterator]();\n        acc = iter.next().value;\n    }\n    for (const a of iter) {\n        acc = f(acc, a);\n    }\n    return acc;\n});</code>\n        </deckgo-highlight-code>\n<h3>해결 방법 - 1</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const reduce = curry((f, acc, iter) =&gt; {\n    if (!iter) {\n        iter = acc[Symbol.iterator]();\n        acc = iter.next().value;\n    }\n    for (const a of iter) {\n        acc = acc instanceof Promise ? acc.then(acc =&gt; f(acc,a)) : f(acc, a);\n    }\n    return acc;\n}); // 1111</code>\n        </deckgo-highlight-code>\n<p>Promise인 경우 then을 실행해주는 방법으로 해결해 줄 수 있다. 하지만 Promise를 만나게 되면 그 뒤로는 계속해서 Promise Chaning이 걸리게 되고, 이런 함수 합성이 많은 경우 불 필요한 분기를 타게 되면서 성능 저하가 일어날 수 있다.</p>\n<h3>해결 방법 - 2</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const reduce = curry((f, acc, iter) =&gt; {\n    if (!iter) {\n        iter = acc[Symbol.iterator]();\n        acc = iter.next().value;\n    }\n    return function recur(acc) {\n        for (const a of iter) {\n            acc = f(acc, a);\n            if (acc instanceof Promise) return acc.then(recur);\n        }\n        return acc;\n    }(acc);\n});\n\ngo(1,\n    a =&gt; a + 10,\n    a =&gt; Promise.resolve(a + 100),\n    a =&gt; a + 1000,\n    log\n);   //1111</code>\n        </deckgo-highlight-code>\n<p>재귀를 이용한 방법을 사용한다. 유명함수를 이용해 return값에 <code>recur</code>함수를 선언해서 내부에서 우선 인자값 함수를 실행한 후 해당 값이 Promise이면 <code>acc.then(recure)</code>로 재귀호출을 하여 Promise의 실제 결과 값이 인자로 전달되는 방식이다.</p>\n<h3>보강 - 첫 인자값이 Promise인 경우</h3>\n<p>go에서 사용되는 첫 번째 인자값이 Promise인 경우에는 아직 에러가 발생한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go(Promise.resolve(1),\n\ta =&gt; a + 10,\n\ta =&gt; Promise.resolve(a + 100),\n\ta =&gt; a + 1000,\n\tlog\n);</code>\n        </deckgo-highlight-code>\n<p>위와 같이 첫번째 인자부터 Promise인 경우 reduce의 유명함수 실행시 첫번째 인자를 Promise로 전달하기 때문에 <code>f(acc, a)</code> 에서 오류가 발생한다. 이런 경우 첫번째 인자값이 Promise인 경우 then을 실행하는 <code>go1</code> 함수를 이용하여 처리를 해주어야한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const go1 = (a, f) =&gt; a instanceof Promise ? a.then(f) : f(a);\n\nconst reduce = curry((f, acc, iter) =&gt; {\n    if (!iter) {\n        iter = acc[Symbol.iterator]();\n        acc = iter.next().value;\n    }\n    return go1(acc, function recur(acc) {\n        for (const a of iter) {\n            acc = f(acc, a);\n            if(acc instanceof Promise) return acc.then(recur);\n        }\n        return acc;\n    });\n});\n\ngo(Promise.resolve(1),\n    a=&gt;a+10,\n    a=&gt;Promise.resolve(a+100),\n    a=&gt;a+1000,\n    log\n);//1111</code>\n        </deckgo-highlight-code>\n<h2>Promise.then의 중요한 규칙</h2>\n<ol>\n<li>여러개의 <code>resolve</code>가 중첩되어 있어도 한번의 <code>then</code>으로 꺼내어 볼 수 있다.</li>\n<li>아무리 <code>Promise</code>가 여러개로 중첩되어있어도 가장 내부에 있는 결과값이 도출되어 전달된다.</li>\n</ol>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">Promise.resolve(Promise.resolve(1)).then(function (a) {\n  log(a);\n});\n\nnew Promise(resolve =&gt; resolve(new Promise(resolve =&gt; resolve(1)))).then(log);</code>\n        </deckgo-highlight-code>","frontmatter":{"title":"비동기: 동시성 프로그래밍 1","date":"2022년 9월 19일 오후 8:30","summary":"비동기 동시성 프로그래밍 - 1","categories":["JavaScript"]}}},{"node":{"id":"7a0e81e3-b287-5fa8-adf3-ce07a3db72d5","fields":{"slug":"/javascript/제너레이터와 이터레이터/"},"html":"<h2>제너레이터</h2>\n<blockquote>\n<p><strong>제너레이터</strong>\n이터레이터이자 이터러블을 생성하는 함수</p>\n</blockquote>\n<ul>\n<li>제너레이터는 위와 같은 문장을 값으로 만들 수 있고, 이 문장을 통해 순회할 수 있는 값을 만들 수 있다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function *gen() {\n\tyield 1;\n\tif (false) yield 2;\n\tyield 3;\n\treturn 100;   // 마지막 리턴값을 정함, 순회할 때는 리턴값을 제외하고 리턴됨\n}\n\nlet iter = gen();\nconsole.log(iter.next())</code>\n        </deckgo-highlight-code>\n<ul>\n<li>제너레이터는 어떠한 값도 순회할 수 있도록 조작할 수 있다.</li>\n</ul>\n<h2>odds</h2>\n<p>: 홀수만 반환하여 순회하는 제너레이터 만들기</p>\n<ul>\n<li>무한 수열(infinity), 제한(limit) 제너레이터를 활용하여 홀수 반환하기</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function *infinity(i = 0) {\n\twhile (true) yield i++;\n}\n\nfunction *limit(l, iter) {\n\tfor (const a of iter) {\n\t\tyield a;\n\t\tif (a == l) return;\n\t}\n}\n\nfunction *odds(limit) {\n\tfor (const a of limit(limit, infinity(1)) {\n\t\tif (a % 2) yield i;\n\t}\n}\n\nlet iter2 = odds(10);\nlog(iter2.next());</code>\n        </deckgo-highlight-code>\n<h2>for of, 전개 연산자, 구조 분해, 나머지 연산자</h2>\n<p>모두 이터러블 프로토콜을 따르고 있는 함수들이다.</p>\n<ul>\n<li>전개연산자와 제너레이터 사용</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">log(...odds(10));   // 1, 3, 5, 7, 9\nlog([...odds(10), ...odds(20)]);   // [1,3,5,7,9,1,3,5,7,9,11,13,15,17,19]</code>\n        </deckgo-highlight-code>\n<ul>\n<li>구조분해와 제너레이터 사용</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const [head, ...tail] = odds(5);\nlog(head, tail);   // 1, [3, 5]</code>\n        </deckgo-highlight-code>\n<ul>\n<li>나머지 연산자와 제너레이터 사용</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const [a, b, ...tail] = odds(5);\nlog(a, b, tail);   // 1, 3, [5, 7, 9]</code>\n        </deckgo-highlight-code>","frontmatter":{"title":"제너레이터와 이터레이터","date":"2022년 9월 18일 오후 3:32","summary":"제너레이터와 이터레이터에 대해 알아보자.","categories":["JavaScript"]}}},{"node":{"id":"3f26fd1b-29f6-5052-a065-40247fdf34ed","fields":{"slug":"/javascript/비동기 동시성 프로그래밍 2/"},"html":"<h2>지연평가 + Promise - L.map, map, take</h2>\n<p>이전에 이터러블을 다루는 <code>L.map, map, take</code>는 기본적으로 동기적으로 돌아가는 상황에서만 정상적인 동작을 하도록 구현하다. 해당 함수들도 <code>reduce, pipe, go</code>처럼 비동기상황에서도 동작하도록 리팩토링 해보자 !</p>\n<h3>예제</h3>\n<p>: go함수의 인자가 Promise객체인 경우</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go([Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)],\n\tL.map(a =&gt; a + 10),\n\ttake(2),\n\tlog\n);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>먼저 L.map에서 Promise를 받을 수 있도록 변경한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">L.map = curry(function *(f, iter) {\n\tfor (const a of iter) \n\t\tyield go1(a, f);\n});\n\n// [Promise, Promise] Promise 객체가 반환된다.</code>\n        </deckgo-highlight-code>\n<ul>\n<li>그런 다음 take 함수에서 Promise내부의 값을 꺼내어 반환하는 로직이 필요하다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const take = curry((l, iter) =&gt; {\n\tlet res = [];\n\titer = iter[Symbol.iterator]();\n\tlet cur;\n\twhile (!(cur = iter.next()).done) {\n\t\tconst a = cur.value;\n\t\tif (a instanceof Promise) a.then(a =&gt; {\n\t\t\tres.push(a);\n\t\t\tif (res.length === l) return res;\n\t\t\t// else -&gt; while\n\t\t});\n\t\tres.push(a);\n\t\tif (res.length === l) return res;\n\t}\n\treturn res;\n});</code>\n        </deckgo-highlight-code>\n<p><code>a</code>가 Promise일 경우 then하도록 구현해주는데, 이 때 <code>l(limit)</code> 보다 추출된 배열의 길이가 작을 경우 다시 while문을 다시 도는 로직이 필요하다. 이것은 다시 함수 안으로 들어와야한다는 것이고 필요한 부분을 잘라서 재귀함수 호출 방식으로 처리하면 된다.</p>\n<ul>\n<li>재귀호출에 필요한 로직을 유명함수에 넣어주고 호출해 준다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const take = curry((l, iter) =&gt; {\n\tlet res = [];\n\titer = iter[Symbol.iterator]();\n\n\treturn function recur(){\n\t\tlet cur;\n\t\t\twhile (!(cur = iter.next()).done) {\n\t\t\t\tconst a = cur.value;\n\t\t\t\tif (a instanceof Promise) a.then(\n\t\t\t\t\ta =&gt; ((res.push(a), res).length === l ? res : recur();\n\t\t\t\t\t// res.push(a);\n\t\t\t\t\t// return res.length === l ? res : recur();\n\t\t\t\t));\n\t\t\t\tres.push(a);\n\t\t\t\tif (res.length === l) return res;\n\t\t\t}\n\t\t\treturn res;\n\t}();\n});</code>\n        </deckgo-highlight-code>\n<p>로직을 조금 더 간결하게 구성하였다.</p>\n<ul>\n<li>아래와 같이 map에 들어가는 함수가 Promise인 경우에도 정상적으로 동작한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go(\n  [1, 2, 3],\n  map(a =&gt; Promise.resolve(a + 10)),\n  log);</code>\n        </deckgo-highlight-code>\n<h2>Kleisli Composition - L.filter, filter, nop, take</h2>\n<p>filter에서 지연평가와 비동기성을 함께 지원하려면 Kleisli Composition을 적용해야한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go([1, 2, 3, 4, 5, 6],\n    L.map(a =&gt; Promise.resolve(a * a)),\n    L.filter(a =&gt; a % 2),\n\t\ttake(2),\n    log\n);   // []</code>\n        </deckgo-highlight-code>\n<p>현재 이 코드는 정상적으로 값이 출력되지 않는다. filter로 넘어오는 값이 Promise이기 때문에 <code>Promise % 2</code> 를 수행하는데 문제가 생기기 때문이다.</p>\n<ul>\n<li>이 부분을 해결하기 위해서 먼저 <code>L.filter</code> 에서 Promise를 받을 수 있도록 변경한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">L.filter = curry(function *(f, iter) {\n\tfor (const a of iter) {\n\t\tconst b = go1(a, f);\n\t\tif(b) yield a;\t\n\t}\n});\n// [Promise, Promise]</code>\n        </deckgo-highlight-code>\n<ul>\n<li>위의 L.filter는 Promise를 반환하기 때문에 Promise내부의 값을 꺼내어 반환하는 로직이 필요하다. 이때 <strong>nop</strong>을 이용한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const nop = Symbol(&#39;nop&#39;);\n\nL.filter = curry(function *(f, iter) {\n\tfor (const a of iter) {\n\t\tconst b = go1(a. f);   // Promise\n\t\tif (b instanceof Promise) yield b.then(b =&gt; b ? a : Promise.reject(nop));\n\t\telse if (b) yield a;\n\t}\n});</code>\n        </deckgo-highlight-code>\n<p>b가 Promise인지 검사를 한 후에 then을 통해 b인자를 풀어주는데 b가 true이면 a를 반환하고 아닌 경우 아무 행동도 하지 않도록 구현해주어야 한다.</p>\n<p>하지만 위의 로직에서 <code>yield</code> 통해 generated되서 전달되기 때문에 다음 함수의 인자값으로 들어가지 않도록 해야한다. 이때 사용하는 것이 <strong>Kleisli Composition</strong>이다.</p>\n<p>위의 코드에서 b의 값이 없거나 <code>false</code>인 경우 <code>reject</code> 을 해주는데 그냥 reject 을 해주는 경우 에러 발생 reject으로 오해할 수 있기 때문에 <strong>nop</strong>이라는 구분자를 만들어 처리해준다.</p>\n<blockquote>\n<p>참고: nop 구분자를 Symbol로 선언한 이유는 Symbol값이라도 객체의 프로퍼티 값으로 사용할 수 있는 Symbol값은 유일한 값이므로 Symbol 값을 키로 갖는 프로퍼티는 다른 어떠한 프로퍼티와도 충돌하지 않기 때문에 약속된 구분자로 사용할 수 있어 사용한다.</p>\n</blockquote>\n<p><a href=\"https://poiemaweb.com/es6-symbol\" target=\"_blank\" rel=\"nofollow\">Symbol | PoiemaWeb</a></p>\n<ul>\n<li>추가적으로 <code>take function</code> 부분에서도 reject에 대한 처리를 해줘야한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const take = curry((l, iter) =&gt; {\n\tlet res = [];\n\titer = iter[Symbol.iterator]();\n\n\treturn function recur(){\n\t\tlet cur;\n\t\t\twhile (!(cur = iter.next()).done) {\n\t\t\t\tconst a = cur.value;\n\t\t\t\tif (a instanceof Promise) {\n\t\t\t\t\ta.then(a =&gt; ((res.push(a), res).length === l ? res : recur()))\n\t\t\t\t\t\t.catch(e =&gt; e === nop ? recur() : Promise.reject(e));\n\t\t\t\t}\n\t\t\t\tres.push(a);\n\t\t\t\tif (res.length === l) return res;\n\t\t\t}\n\t\t\treturn res;\n\t}();\n});</code>\n        </deckgo-highlight-code>\n<p>take에서 reject을 통해 catch가 잡혔을 때 해당 paramater가 nop일 경우 무시하고 다음 함수를 평가하도록 해야한다.</p>\n<h2>reduce에서 nop지원</h2>\n<p>reduce도 nop을 이용해서 지연성과 비동기성을 지원하도록 만들어보자.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go([1, 2, 3, 4, 5],\n    L.map(a =&gt; Promise.resolve(a * a)),\n    L.filter(a =&gt; Promise.resolve(a % 2)),\n    reduce(add),\n\t\tlog);\n// 1[object Promise][object Promise][object Promise] Uncaught (in promise) Symbol(nop)</code>\n        </deckgo-highlight-code>\n<p>현재 이 코드는 Promise를 지원하지 않는다.</p>\n<ul>\n<li>기존에 구현한 reduce</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const reduce = curry((f, acc, iter) =&gt; {\n    if (!iter) {\n        iter = acc[Symbol.iterator]();\n        acc = iter.next().value;\n    }\n    return go1(acc, function recur(acc) {\n        for (const a of iter) {\n            acc = f(acc, a);\n            if(acc instanceof Promise) return acc.then(recur);\n        }\n        return acc;\n    });\n});</code>\n        </deckgo-highlight-code>\n<ul>\n<li>\n<p>reduce내부의 for내부에서 nop을 캐치하는 부분과 a를 풀어주는 부분을 만들면 된다.  저 두 부분만 해결하면 되기에 모듈로 만들어서 호출하도록 구현한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const reduceF = (acc, a, f) =&gt; \n\ta instanceof Promise ? a.then(a =&gt; f(acc, a), e =&gt; e === nop ? acc : Promise.reject(e)) : f(acc, a);\n\nconst reduce = curry((f, acc, iter) =&gt; {\n    if (!iter) {\n\t    iter = acc[Symbol.iterator]();\n      acc = iter.next().value;\n    }\n    return go1(acc, function recur(acc) {\n        for (const a of iter) {\n            acc = reduceF(acc, a, f)\n            if(acc instanceof Promise) return acc.then(recur);\n        }\n        return acc;\n    });\n});</code>\n        </deckgo-highlight-code>\n<ul>\n<li><code>reduceF</code>라는 함수를 만들어 a가 Promisel일 경우 then을 통해 a를 꺼내어 <code>f(acc, a)</code>를 수행하도록 해주고 <code>reject(nop)</code>인 경우 acc를 그대로 반환한다.</li>\n<li>Promise가 아닌 경우 즉시 <code>f(acc, a)</code> 를 실행한다.</li>\n</ul>\n</li>\n</ul>\n<h3>reduce 모듈화</h3>\n<p>reduce에서 iter가 없는 경우에 대한 처리를 하는 로직을 모듈화 할 수 있다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const head = iter =&gt; go1(take(1, iter), ([h]) =&gt; h);\n\nconst reduce = curry((f, acc, iter) =&gt; {\n    if (!iter) return reduce(f, head(iter = acc[Symbol.iterator]()), iter);\n\n    return go1(acc, function recur(acc) {\n        for (const a of iter) {\n            acc = reduceF(acc, a, f)\n            if(acc instanceof Promise) return acc.then(recur);\n        }\n        return acc;\n    });\n});</code>\n        </deckgo-highlight-code>\n<ul>\n<li>head라는 함수를 만들어 인자값으로 받은 iter에서 첫번째 인자값을 take로 가져온다. 그 뒤 take는 배열값을 반환하기 때문에 구조분해로 내부값을 꺼내 반환한다.</li>\n<li>head함수로 reduce 함수에서 iter가 없는 경우 재귀적으로 인자를 만들어 다시 호출해 정상동작하도록 한다.</li>\n</ul>\n<h2>지연 평가 + Promise의 효율성</h2>\n<p>비동기 상황이 함수 대기열에 등록되어있는 경우 전체적인 성능 부분에서 많은 딜레이가 생길 수 있다. 지연 평가를 함으로써 이 부분의 성능적인 이점을 얻을 수 있다.</p>\n<ul>\n<li>비동기 상황이 함수 대기열에 등록되어있는 경우 - 지연평가</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go([1, 2, 3, 4, 5, 6, 7, 8],\n    L.map(a =&gt; {\n        log(a);\n        return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(a * a), 1000))\n    }),\n    L.filter(a =&gt; {\n        log(a);\n        return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(a % 2), 1000))\n    }),\n    take(2),\n    // reduce(add),\n    log\n)</code>\n        </deckgo-highlight-code>\n<p>위와 같이 지연평가를 하는 <code>L.map, L.filter</code> 를 사용하는 경우 필요한 값을 다 구했다면, 그 다음 내용들을 수행되지 않기 때문에 성능적인 이점을 많이 얻을 수 있다.</p>\n<h2>지연된 함수열을 병렬적으로 평가하기 - C.reduce, C.take [1]</h2>\n<p>현재까지 구현된 <code>go</code> 함수의 동작 방식은 첫번 째 인자인 배열의 첫번째 값(<code>1</code>)부터 <code>L.map, L.filter</code> 을 지나면서 대기하다가, <code>reduce</code> 에 리턴된 값을 전달하면서 완료되고, 이와 동일한 과정을 첫번 째 인자의 배열 순서대로(<code>1 → 2 → 3 → 4 → 5</code>) 반복하면서 진행되고 있다.</p>\n<p>결국 reduce함수에서는 앞에 나열된 함수들이 처리 해줄 때까지 기다리고 있는 셈인데, 모든 인자를 한번에 실행시키면 더 빠르게 결과를 만들 수 있을것이다.</p>\n<ul>\n<li><code>C.reduce</code> 를 생성하여 reduce에 모든 값들을 전부 나열해서 보내어 모든 함수를 동시에 실행시키면 좀 더 빠르게 결과를 만들 수 있다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const C = {};\n\nC.reduce = curry((f, acc, iter) =&gt; iter ?\n\treduce(f, acc, [...iter]) :\n\treduce(f, [...acc]));</code>\n        </deckgo-highlight-code>\n<h2>지연된 함수열을 병렬적으로 평가하기 - C.reduce, C.take [2]</h2>\n<h3>문제</h3>\n<p>다음과 같이 여러 함수열을 비동기 상황으로 사용하다 보면 여러 Promise에서 예측하기 어려운 다양한 에러가 발생할 수 있다.</p>\n<p>JavaScript 특성상 Promise에서 reject은 호출된 시점에서 catch를 해주어야 한다. 이후 원하는 시점에서 이전에 발생한 reject에 대해 처리해주려고 해도 방법이 없다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go([1, 2, 3, 4, 5, 6, 7, 8, 9],\n\tL.map(a =&gt; delay1000(a * a)),\n  L.filter(a =&gt; delay1000(a % 2)),\n  L.map(a =&gt; delay1000(a * a)),\n  C.reduce(add),\n\tlog);\n\n// Uncaught (in promise) Symbol(nop)\n// Uncaught (in promise) Symbol(nop)\n// Uncaught (in promise) Symbol(nop)</code>\n        </deckgo-highlight-code>\n<ul>\n<li>위의 상황과 같이 예기치 않은 reject로 에러 로그가 출력될 경우를 대비하기 위한 처리가 필요하다.</li>\n</ul>\n<h3>해결방법</h3>\n<p>이 때, Promise reject이 발생하기 전에 catch를 해준다면 이후 에러 로그를 출력하지 않도록 할 수 있다.</p>\n<p>현재 Promise reject에 대해 당장은 아무일도 하지 않도록 처리해주고, 이후 원하는 시점에서 해당 오류에 대해 catch할 수 있게 된다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function noop() {}  // 아무일도 하지 않는 함수\nconst catchNoop = arr =&gt;\n\t(arr.forEach(a =&gt; a instanceof Promise ? a.catch(noop) : a), arr);   // 받은 array를 그대로 리턴하도록 구현\n\nC.reduce = curry((f, acc, iter) =&gt; {\n\tconst iter2 = catchNoop(iter ? [...iter] : [...acc]);   // reduce를 실행하기 전에 미리 에러 catch를 해놓음\n\n\treturn iter ?\n\t\treduce(f, acc, iter2) :\n\t\treduce(f, iter2));\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>\n<p><code>noop</code> 함수를 선언해서 아무일도 하지 않는 함수를 정의한다.</p>\n</li>\n<li>\n<p><code>catchNoop</code> 함수에서 각 Promise에 임시적으로 catch를 한다. catch를 선언하지 않거나, reject뒤에 즉시 실행 시키지 않을 경우에는 원하는 시점에 catch를 해줄 수 있다.</p>\n</li>\n<li>\n<p>C.reduce 를 조금더 간결하게 리팩토링 하였다.</p>\n</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">C.reduce = curry((f, acc, iter) =&gt; iter ? \n\treduce(f, acc, catchNoop([...iter])) : \n\treduce(f, catchNoop([...acc])));</code>\n        </deckgo-highlight-code>\n<h3>C.take</h3>\n<p>C.take함수도 동일한 방법으로 구현할 수 있다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">C.take = curry((l, iter) =&gt; take(l, catchNoop([...iter])));</code>\n        </deckgo-highlight-code>\n<h2>즉시 병렬적으로 평가하기 - C.map, C.filter</h2>\n<p>지금까지는 평가, 결론을 짓는 <code>reduce, take</code>함수에서 여러개의 대기 함수열들을 병렬적으로 실행하는 방식을 구현해보았다.</p>\n<p>여기서는 특정 함수라인에서만 병렬적으로 활용하고 싶은 경우를 위한 <code>C.map, C.filter</code> 를 구현해보겠다.</p>\n<ul>\n<li>먼저 <code>takeAll</code> 함수를 만들어준다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">C.takeAll = C.take(Infinity);</code>\n        </deckgo-highlight-code>\n<ul>\n<li><code>L.map</code>과 <code>C.takeAll</code>을 이용하여 <code>C.map</code>을 생성한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">C.map = curry(pipe(L.map, C.takeAll));</code>\n        </deckgo-highlight-code>\n<ul>\n<li><code>L.filter</code>과 <code>C.takeAll</code>을 이용하여 <code>C.filter</code> 생성한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">C.filter = curry(pipe(L.filter, C.takeAll));</code>\n        </deckgo-highlight-code>\n<ul>\n<li>아래와 같이 사용가능하다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">C.map(a =&gt; delay1000(a * a), [1, 2, 3, 4]).then(log);\nC.filter(a =&gt; delay1000(a % 2), [1, 2, 3, 4]).then(log);</code>\n        </deckgo-highlight-code>\n<h2>즉시, 지연, Promise, 병렬적 조합하기</h2>\n<p>처음 구현한 map, filter, reduce, take 등의 함수를 부하 정도나, 엄격함의 정도등을 고려한 상황에 맞춰 알맞게 선택하여 사용하면 된다.</p>\n<ul>\n<li>즉시 함수 사용 (=가장 엄격하게 평가함)</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go([1, 2, 3, 4, 5, 6, 7, 8, 9],\n\tmap(a =&gt; delay1000(a * a)),\n  filter(a =&gt; delay1000(a % 2)),\n  map(a =&gt; delay1000(a + 1)),\n  take(2),\n\tlog);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>지연 함수 사용</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go([1, 2, 3, 4, 5, 6, 7, 8, 9],\n\tL.map(a =&gt; delay1000(a * a)),\n  L.filter(a =&gt; delay1000(a % 2)),\n  L.map(a =&gt; delay1000(a + 1)),\n  take(2),\n\tlog);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>병렬 함수 사용</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go([1, 2, 3, 4, 5, 6, 7, 8, 9],\n\tC.map(a =&gt; delay1000(a * a)),\n  C.filter(a =&gt; delay1000(a % 2)),\n  C.map(a =&gt; delay1000(a + 1)),\n  C.take(2),\n\tlog);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>복합적으로 구성하여 사용</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go([1, 2, 3, 4, 5, 6, 7, 8, 9],\n\tL.map(a =&gt; delay1000(a * a)),\n  L.filter(a =&gt; delay1000(a % 2)),\n  L.map(a =&gt; delay1000(a + 1)),\n  C.take(2),\n\tlog);</code>\n        </deckgo-highlight-code>\n<p>📌  <strong>결론: 위와 같이 함수들을 적절하게 필요한 상황에 따라 활용하여 사용하면 된다.</strong></p>","frontmatter":{"title":"비동기: 동시성 프로그래밍 2","date":"2022년 9월 20일 오후 2:49","summary":"비동기 동시성 프로그래밍 - 2","categories":["JavaScript"]}}},{"node":{"id":"8700321f-7d95-5727-af9f-311840f40997","fields":{"slug":"/javascript/지연성 1/"},"html":"<h2>range와 느긋한 L.range</h2>\n<h3>range함수</h3>\n<ul>\n<li>limit를 인자로 받아 그 크기만큼 배열을 반환하는 함수</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const add = (a, b) =&gt; a + b;\n\nconst range = (l) =&gt; {\n\tlet i = -1;\n\tlet res = [];\n\twhile (++i &lt; l) {\n\t\tres.push(i);\n\t}\n\n\treturn res;\n};\n\nconst list = range(4);\n\nreduce(add, list);</code>\n        </deckgo-highlight-code>\n<h3>느긋한 L.range 함수</h3>\n<p>: 즉시 실행해서 배열의 형태를 만드는 것이 아니라, iterator가 순회할 때 <strong>그 때!</strong> 하나씩 만들어짐(=평가가됨).</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const add = (a, b) =&gt; a + b;\n\nconst L = {};\nL.range = function *(l) {\n\tlet i = -1;\n\twhile (++i &lt; l) {\n\t\tyield i;\n\t}\n};\n\nconst list = L.range(4);   \n\nreduce(add, list);   // iterator가 출력됨</code>\n        </deckgo-highlight-code>\n<h3>! 차이점</h3>\n<p>일반 range함수는 함수 호출 시점에 배열을 만든 후 순회하면서 이터레이터를 생성하지만, 느긋한 L.range함수는 함수 호출시점에는 실제 값이 대입되지 않는다.</p>\n<p>L.range함수는 이터레이터의 내부를 순회할 때마다 하나씩 값을 만드는 방식이기 때문에 <strong>성능적으로 훨씬 효율적이다.</strong></p>\n<p>특히, 배열의 길이가 길거나, 무한 수열 등을 사용하는 경우 성능적인 이득을 더 많이 볼 수 있다.</p>\n<h3>range와 느긋한 L.range 성능 비교 해보기</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function test(name, time, f) {\n\tconsole.time(name);\n\twhile(time--) f();\n\tconsole.timeEnd(name);\n}\n\n// test(&#39;range&#39;, 10, () =&gt; reduce(add, range(1000000)));\n// test(&#39;L.range&#39;, 10, () =&gt; reduce(add, L.range(1000000)));</code>\n        </deckgo-highlight-code>\n<h2>take</h2>\n<ul>\n<li>Iterator에서 원하는 갯수만큼의 값을 얻어오는 함수.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const take = (l, iter) =&gt; {\n\tlet res = [];\n\tfor (const a of iter) {\n\t\tres.push(a);\n\t\tif (res.length === l) return res;\n\t}\n\treturn res;\n}\n\ntake(5, L.range(1000000))  // 5개만 만들기 때문에 훨씬 성능적으로 유리함.</code>\n        </deckgo-highlight-code>\n<h2>이터러블 중심 프로그래밍에서의 지연 평가 (Lazy Evaluation)</h2>\n<ul>\n<li>제때 계산법: 평가가 필요할 때까지 미루다가 평가가 이루어져야할 때 평가하여 성능적으로 유리하게 구현</li>\n<li>느긋한 계산법</li>\n<li>제너레이터/이터레이터 프로토콜을 기반으로 구현된다.</li>\n</ul>\n<h2>L.map</h2>\n<p>제너레이터/이터레이터기반의 지연성을 가진 L.map을 구현한다.</p>\n<p>실제 next로 실행하기 전까지는 준비!만 하고 있는 함수라고 생각하면 된다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">L.map = function *(f, iter) {\n\tfor (const a of iter) yield f(a);\n}\n\nconst it = L.map(a =&gt; a + 10, [1, 2, 3]);\nit.next();   // next를 통해서 평가하는 만큼만 생성/실행함.</code>\n        </deckgo-highlight-code>\n<h2>L.filter</h2>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">L.filter = function *(f, iter) {\n\tfor (const a of iter) if(f(a)) yield a;\n}\n\nconst it = L.filter(a =&gt; a % 10, [1, 2, 3, 4]);\nit.next();   // { value: 1, done: false }\nit.next();   // { value: 3, done: false }</code>\n        </deckgo-highlight-code>\n<h2>map, filter 계열 함수들이 가지는 결합 법칙</h2>\n<ul>\n<li>사용하는 데이터가 무엇이든지, 사용하는 보조 함수가 순수 함수라면 무엇이든지 아래와 같이 결합한다면 둘다 결과가 같다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">[[mapping, mapping], [filtering, filtering], [mapping, mapping]]\n=\n[[mapping, filtering, mapping], [mapping, filtering, mapping]]</code>\n        </deckgo-highlight-code>","frontmatter":{"title":"지연성 1","date":"2022년 9월 18일 오후 8:44","summary":"지연성을 가진 range, take, map, filter에 대해 알아보자","categories":["JavaScript"]}}},{"node":{"id":"31d58176-8969-57d9-b92c-1d5c9e99bf03","fields":{"slug":"/javascript/지연성 2/"},"html":"<h2>결과를 만드는 함수 reduce, take</h2>\n<ul>\n<li>기존 배열을 깨뜨려서(=변형시켜서) 연산을 하기 때문에 결과를 만드는 함수라고 한다.</li>\n<li>map, filter처럼 지연성을 가진다고 하기는 어렵지만, 결과를 만드는 시작점을 만들기 때문에 iterator의 값을 꺼내어 연산을 시작한다.</li>\n</ul>\n<h3>queryString 함수 만들기</h3>\n<p>reduce를 응용해서 객체로 부터 url의 queryString을 만드는 함수 queryStr 구현</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const queryStr = pipe(\n\tObject.entries,\n\tmap(([k, v]) =&gt; `${k}=${v}`),\n\treduce((a, b) =&gt; `${a}&amp;${b}`)\n);\n\nlog(queryStr({ limit: 10, offset: 10, type: &#39;notice&#39; })</code>\n        </deckgo-highlight-code>\n<h3>Array.prototype.join보다 다형성이 높은 join</h3>\n<p>기존 Array에서 제공하는 join함수는 지연평가를 제공하지 않는다. Iterator를 활용하여 더 다형성 높은 join함수를 만들 수 있다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const join = curry((sep = &#39;,&#39;, iter) =&gt; reduce((a, b) =&gt; `${a}${sep}${b}`, iter));</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const queryStr = pipe(\n\tObject.entries,\n\tmap(([k, v]) =&gt; `${k}=${v}`),\n\tjoin(&#39;&amp;&#39;)\n);\n\nlog(queryStr({ limit: 10, offset: 10, type: &#39;notice&#39; })</code>\n        </deckgo-highlight-code>\n<ul>\n<li>generator 함수에서의 join</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function *a() {\n\tyield 10;\n\tyield 11;\n\tyield 12;\n\tyield 13;\n}\n\njoin(&#39; - &#39;, a());</code>\n        </deckgo-highlight-code>\n<ul>\n<li>지연성을 가진 L.map과 L.entries 적용하기</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">L.entries = function *(obj) {\n\tfor (const k in obj) yield [k, obj[k]];\n}\n\nconst queryStr = pipe(\n\tL.entries,\n\tL.map(([k, v]) =&gt; `${k}=${v}`),\n\tjoin(&#39;&amp;&#39;)\n);\n\nlog(queryStr({ limit: 10, offset: 10, type: &#39;notice&#39; });</code>\n        </deckgo-highlight-code>\n<ul>\n<li>join으로 넘어갈 당시에 인자값은 iterable해서 실제 값이 생성되기 전이므로 지연성을 가짐.</li>\n</ul>\n<h2>take, find</h2>\n<blockquote>\n<p><strong>find함수</strong>: take로 결론을 만들어내는 함수 이다.</p>\n</blockquote>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const users = [\n    {age: 32},\n    {age: 31},\n    {age: 37},\n    {age: 28},\n    {age: 25},\n    {age: 32},\n    {age: 31},\n    {age: 37}\n];\n\nconst find = curry((f, iter) =&gt; go(\n\titer,\n\tL.filter(f),\n\ttake(1),\n\t([a]) =&gt; a\n));\n\nlog(find(u =&gt; u.age &lt; 30)(users));\n\ngo(users,\n    L.map(u =&gt; u.age),\n    find(n =&gt; n &lt; 30),\n    log);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>인자값으로 받은 <code>iter</code>값을 <code>L.filter</code>로 이터러블객체를 take에 전달하면 take함수에서 실제로 결과를 만들어내기위해 값들을 호출하게 되고, filter condition에 부합하는 값을 찾으면 반환하여 전달 후 구조분해하여 반환한다.</li>\n<li>지연된 평가를 사용하였기에 filter 부분에서 모든 값을 다 condition과 비교하며 비교후 완성된 값을 반환하는게 아니라 generator 호출을 계속 시도하여 filter condition과 비교하며 부합된 값을 찾는데 <code>take(1)</code>이기에 하나의 값을 찾는 순간 로직은 종료되며, 만일, users의 목록이 1000만개인데 10만개쯤에서 결과를 찾는다면 그 뒤 990만번의 불필요한 연산을 막을 수 있다.</li>\n</ul>\n<h2>L.map, L.filter로 map과 filter 만들기</h2>\n<ul>\n<li>L.map과 take(Infinity)을 활용하여 map 구현하기</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const map = curry((f, iter) =&gt; go(\n\titer,\n\tL.map(f),\n\ttake(Infinity)\n));\n\nlog(map(a =&gt; a + 10, L.range(4)));</code>\n        </deckgo-highlight-code>\n<p>pipe를 이용하면 더 간결하게 작성할 수 있다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const map = curry(pipe(L.map, take(Infinity)));\n\nlog(map(a =&gt; a + 10, L.range(4)));</code>\n        </deckgo-highlight-code>\n<ul>\n<li>L.filter와 take(Infinity)을 활용하여 filter구현하기</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const filter = curry(pipe(L.filter, take(Infinity)));\n\nlog(filter(a =&gt; a % 2, range(4)));</code>\n        </deckgo-highlight-code>\n<ul>\n<li>take(Infinity) 공통 함수로 작성</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const takeAll = take(Infinity);\n\nconst map = curry(pipe(L.map, takeAll));\nconst filter = curry(pipe(L.filter, takeAll));</code>\n        </deckgo-highlight-code>\n<h2>L.flatten, flatten</h2>\n<blockquote>\n<p><strong>flatten</strong>: 여러가지 depth를 가진 이터레이터 객체를 평탄화해서 펼친 후 반환해주는 함수</p>\n<p>여러 depth를 가진 배열을 일차원 배열로 만들어주는 것과 유사하다.</p>\n</blockquote>\n<ul>\n<li>L.flattten 생성하기</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">L.flatten = function *(iter) {\n\tfor (const a of iter) {\n\t\tif (isIterator(a)) for (const b of a) yield b;\n\t\telse yield a;\n\t}\n}\n\nconst it = L.flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]]);\nlog([...it]);   // 전체 배열 리턴\nlog(it.next());</code>\n        </deckgo-highlight-code>\n<p>📌  <code>yield *iterable</code> 은 <code>for (const val of iterable) yield val;</code> 와 같다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">L.flatten = function *(iter) {\n  for (const a of iter) {\n    if (isIterable(a)) yield *a;\n    else yield a;\n  }\n};</code>\n        </deckgo-highlight-code>\n<ul>\n<li>flatten 생성하기 (L.flatten, takeAll)\n<ul>\n<li>이전에 만든 지연성 함수를 결과를 도출해내는 함수(take, reduce)를 통해 즉시평가가 가능하게 합니다.</li>\n</ul>\n</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const flatten = pipe(L.flatten, takeAll);\nlog(flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]]));</code>\n        </deckgo-highlight-code>\n<ul>\n<li>take 적용</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">log(take(6, L.flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]])));</code>\n        </deckgo-highlight-code>\n<h3><strong><strong>L.deepFlat</strong></strong></h3>\n<p>: 만일 깊은 Iterable을 모두 펼치고 싶다면 아래와 같이 <code>L.deepFlat</code>을 구현하여 사용할 수 있다. <code>L.deepFlat</code>은 깊은 Iterable을 펼쳐준다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">L.deepFlat = function *f(iter) {\n  for (const a of iter) {\n    if (isIterable(a)) yield *f(a);\n    else yield a;\n  }\n};\n\nlog([...L.deepFlat([1, [2, [3, 4], [[5]]]])]);\n// [1, 2, 3, 4, 5];</code>\n        </deckgo-highlight-code>\n<h2>L.flatMap</h2>\n<ul>\n<li>\n<p>조건을 이용해서 배열의 값을 변경할 수 있다는 점이 flatten과 다르다.</p>\n</li>\n<li>\n<p>L.flatMapr 구현</p>\n</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">L.flatMap = curry(pipe(L.map, L.flatten));\n\nvar it = L.flatMap(a =&gt; a, [[1, 2], [3, 4], [5, 6, 7]]);\nlog([...it]);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>flatMap 구현</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const flatMap = curry(pipe(L.map, flatten));\n\nlog(flatMap(a =&gt; a, [[1, 2], [3, 4], [5, 6, 7]]));</code>\n        </deckgo-highlight-code>\n<ul>\n<li>응용</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">log(flatMap(L.range, map(a =&gt; a + 1, [1, 2, 3])));\n\nvar it = L.flatMap(L.range, map(a =&gt; a + 1, [1, 2, 3]));\nlog(it.next());\nlog(it.next());\n\nlog(take(3, L.flatMap(L.range, map(a =&gt; a + 1, [1, 2, 3]))));</code>\n        </deckgo-highlight-code>\n<h2>2차원 배열 다루기</h2>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const arr = [\n\t[1, 2],\n\t[3, 4, 5],\n\t[6, 7, 8],\n\t[9, 10]\n];\n\ngo(\n\tL.flatten,\n\tL.filter(a =&gt; a % 2),\n\tL.map(a =&gt; a * a),\n\ttake(3),\n\treduce(add)\n)</code>\n        </deckgo-highlight-code>\n<h2>지연성 / 이터러블 중심의 실무적인 코드</h2>\n<h3>문제1. 모든 유저의 가족들 중 미성년자의 이름을 3개만 반환하라.</h3>\n<h2>함수형 프로그래밍이란 ?</h2>\n<p>≒ <strong>이터러블 중심 프로그래밍</strong></p>\n<blockquote>\n<p>조합되어있는 함수에 맞는 데이터를 구성하는 것이다.</p>\n</blockquote>\n<p>⁉️  객체지향 프로그래밍은 데이터에 따라 맞는 함수를 구성하는 것이다.</p>","frontmatter":{"title":"지연성 2","date":"2022년 9월 19일 오후 12:58","summary":"지연성을 가진 reduce, take, find, join 함수를 구현해보자.","categories":["JavaScript"]}}},{"node":{"id":"5c427ba3-669b-5289-97c1-539b9319a00e","fields":{"slug":"/javascript/코드를 값으로 다루어 표현력 높이기/"},"html":"<h2>go</h2>\n<blockquote>\n<p>인자로 함수리스트를 받아 첫 번째 인자값을 초기값으로 하여, 두 번째 인자부터 함수들의 리스트를 받아 함수를 실행하여 얻은 <strong>반환 값을 다음 함수로 넘겨</strong> 함수를 리턴한다.</p>\n</blockquote>\n<h3>예제</h3>\n<ul>\n<li>요구사항\n<ul>\n<li>111과 같은 결과를 출력하는 함수를 작성하시오.</li>\n</ul>\n</li>\n</ul>\n<p>첫 번째 인자가 <code>0</code> 인 아래 로직에서 두번째 인자인 <code>a => a + 1</code> 함수에 <code>0</code> 이 전달되고, 이 함수의 반환값인 <code>1</code> 을 다음 <code>a => a + 10</code> 으로 전달한다.</p>\n<p>이와 같이 인자에 전달된 함수 리스트를 모두 순환할 때까지 해당 과정을 반복하여 축약된 결과인 <code>111</code> 이 최종적으로 출력된다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const go = (...args) =&gt; reduce((a, f) =&gt; f(a), args);\n\ngo(\n\t0,\n\ta =&gt; a + 1,\n\ta =&gt; a + 10,\n\ta =&gt; a + 100,\n\tlog);   // 111</code>\n        </deckgo-highlight-code>\n<h2>pipe</h2>\n<blockquote>\n<p>go 함수와의 가장 큰 차이점은 go는 인자값으로 들어온 함수에서 즉시실행하여 결과값을 반환해 다음 함수로 전달한다면 pipe 함수는 함수 자체를 반환하여 최종적으로 인자값으로 받은 함수리스트를 합성해서 합성된 합수를 가지고 로직을 수행합니다.</p>\n</blockquote>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const pipe = (...fs) =&gt; (a) =&gt; go(a, ...fs);\nconst f = pipe(\n    a =&gt; a + 1,\n    a =&gt; a + 10,\n    a =&gt; a + 100\n);\n\nf(0);  // 111</code>\n        </deckgo-highlight-code>\n<ul>\n<li>pipe 기능 추가\n<ul>\n<li>위에서 구현한 pipe함수는 인자 값을 하나만 받기 때문에 여러개 인자를 사용하기에 복잡하기 때문에, 여러 개 인자를 받을 수 있도록 구현</li>\n</ul>\n</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const pipe = (f, ...fs) =&gt; (...as) =&gt; go(f(...as), ...fs);\n\nconst f = pipe(\n\t(a, b) =&gt; a + b,\n\ta =&gt; a + 10,\n\ta =&gt; a + 100\n);\n\nf(0, 1);</code>\n        </deckgo-highlight-code>\n<p>인자값을 하나만 보내고 싶으면 pipe함수의 첫 번째 인자값을 <code>a => a</code>로 해주면 문제없이 잘 동작한다.</p>\n<h2>go를 사용하여 읽기 좋은 코드로 만들기</h2>\n<p>map, filter, reduce 중첩 사용시 사용했던 아래 코드를 go를 사용하여 가독성 높은 코드로 리팩토링 해보자.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">reduce(add, 0, map(p =&gt; p.price, filter(p =&gt; p.price &lt; 30000, books)))</code>\n        </deckgo-highlight-code>\n<ul>\n<li>리팩토링 결과</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go(\n    books,\n    books =&gt; filter(p =&gt; p.price &lt; 30000, books),\n    books =&gt; map(p =&gt; p.price, books),\n    prices =&gt; reduce(add, prices),\n    log\n);</code>\n        </deckgo-highlight-code>\n<p>코드 라인수는 증가했지만 가독성은 높아졌다. books를 첫번째 인자로 받아 <code>fillter, map, reduce</code> 를 차례로 수행하고 마지막 <code>log</code> 로 출력한다.</p>\n<h2>go + curry를 사용하여 더 읽기 좋은 코드로 만들기</h2>\n<h3>currying이란?</h3>\n<p>여러 개의 인자를 가진 함수를 호출하는 경우, 파라미터의 수보다 적은 수의 파라미터를 인자로 받으면 누락된 파라미터를 인자로 받는 기법.</p>\n<p>즉, 커링은 함수 하나가 n개의 인자를 받는 과정을 n개의 함수로 각각의 인자를 받도록 하는 것이다.</p>\n<p>예를 들면, <code>f(a, b, c)</code> 처럼 단일 호출로 처리하는 함수를 <code>f(a)(b)(c)</code> 형식으로 변환하는 것을 말한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function curry(f) { // 커링 변환을 하는 curry(f) 함수\n  return function(a) {\n    return function(b) {\n      return f(a, b);\n    };\n  };\n}\n\n// usage\nfunction sum(a, b) {\n  return a + b;\n}\n\nlet curriedSum = curry(sum);\n\nlog(curriedSum(1)(2));</code>\n        </deckgo-highlight-code>\n<p><strong>‼️ 주의</strong></p>\n<p>: <strong>커링 함수에서 인자의 순서는 매우 중요하다. 앞에 있는 인자일수록 변동가능성이 낮아야하고 뒤로갈수록 변동가능성이 높아야한다. 그렇기 때문에 커링 함수를 만들 때 인자 순서를 잘 고려해서 구현해야 한다 !!</strong></p>\n<h3>Curry 함수 만들어보기</h3>\n<p>curry 함수는 인자값으로 함수(f)를 받아서 함수를 리턴한다. 반환된 함수가 실행되었을 때 인자값이 2개 이상인 경우 즉시 함수(<code>f(a, ..._)</code>)를  실행하고, 2개 미만일 경우 함수(<code>(..._) => f(a, ..._)</code>)를 다시 반환 후 가지고 있다가 나중에 인자값(<code>…_</code>)을 받으면 받아놨던 인자(<code>f(a)</code>)와 합쳐 실행한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const curry = f =&gt; (a, ..._) =&gt; _.length ? f(a, ..._) : (..._) =&gt; f(a, ..._);</code>\n        </deckgo-highlight-code>\n<h3>예제 코드</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const mult = curry((a, b) =&gt; a * b);\n\nlog(mult);        // (a, ..._) =&gt; _.length ? f(a, ..._) : (..._) =&gt; f(a, ..._);\nlog(mult(3));     // (..._) =&gt; f(3, ..._);\nlog(mult3(10));   // 30\nlog(mult3(3)(5)); // 15\nlog(mult3(3, 5)); // 15</code>\n        </deckgo-highlight-code>\n<h2>map+filter+reduce 중첩 함수를 Currying으로 리팩토링</h2>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const map = curry((f, iter) =&gt; {\n\tlet res = [];\n\tfor (const a of iter) {\n\t\tres.push(f(a));\n\t}\n\n\treturn res;\n});\n\n// filter, reduce함수도 동일하게 적용\n\ngo(\n\tproducts,\n\tproducts =&gt; filter(p =&gt; p.price &lt;= 20000)(products),\n\tproducts =&gt; map(p =&gt; p.price)(products),\n\tprices =&gt; reduce(add)(prices),\n\tconsole.log\n);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>각 함수에 products, prices등을 인자로 받아 함수에서 2차 함수로 해당 파라미터를 넣어주고있다. 이것은 하나로 합칠 수 있다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">go(\n\tproducts,\n\tfilter(p =&gt; p.price &lt;= 20000),\n\tmap(p =&gt; p.price),\n\treduce(add),\n\tconsole.log\n);</code>\n        </deckgo-highlight-code>\n<p>예제로 작성하진 않았지만 20000원 이하의 제품의 총액을 반환하는 예제를 구현하였는데 해당 조건을 변경하고 여러가지 기능을 구현할 수 있으므로 <strong>중복되는 내용을 필요에 따라 함수로 분리하여(=모듈화)</strong> 더 간결하게 표현한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const total_price = pipe(\n\t\tmap(p =&gt; p.price),\n\t\treduce(add));\n\nconst base_total_price = predi =&gt; pipe(\n\tfilter(predi),\n\ttotal_price,\n);\n\ngo(\n\tproducts,\n\tbase_total_price(p =&gt; p.price &lt;= 20000),\n\tconsole.log\n);</code>\n        </deckgo-highlight-code>","frontmatter":{"title":"코드를 값으로 다루어 표현력 높이기","date":"2022년 9월 18일 오후 5:25","summary":"go, pipe, curry 함수에 대해 알아보자.","categories":["JavaScript"]}}},{"node":{"id":"6a9ac9a8-8203-5e3d-83b1-ddac6436df66","fields":{"slug":"/javascript/함수형 자바스크립트 기본기/"},"html":"<h2>평가</h2>\n<ul>\n<li>코드가 계산(Evaluation)되어 값을 만드는 것.</li>\n</ul>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">&gt; 1\n&gt; 1 + 2\n&gt; [1, 2 + 3]</code>\n        </deckgo-highlight-code>\n<h2>일급</h2>\n<ul>\n<li>값으로 다룰 수 있다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const a;</code>\n        </deckgo-highlight-code>\n<ul>\n<li>변수에 담을 수 있다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const a = 10;</code>\n        </deckgo-highlight-code>\n<ul>\n<li>함수의 인자로 사용될 수 있다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const add10 = a =&gt; a + 10;</code>\n        </deckgo-highlight-code>\n<ul>\n<li>함수의 결과로 사용될 수 있다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const add10 = a =&gt; a + 10;\nlog(add(1));   // 11의 결과로 사용됨.</code>\n        </deckgo-highlight-code>\n<h2>일급 함수</h2>\n<aside>\n💡 javascript에서 함수는 일급이다.\n</aside>\n<ul>\n<li>함수를 값으로 다룰 수 있다.</li>\n<li>조합성과 추상화의 도구이다.</li>\n<li>원하는 시점에 평가하여 결과를 사용할 수 있다.</li>\n<li>함수는 함수를 리턴할 수도 있다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const f1 = () =&gt; () =&gt; 1;\nlog(f1()) // () =&gt; 1</code>\n        </deckgo-highlight-code>\n<h2>고차 함수</h2>\n<ul>\n<li>함수를 값으로 다루는 함수.</li>\n</ul>\n<h3>함수를 인자로 받아서 실행하는 함수</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const apply1 = f =&gt; f(1);   // (a =&gt; a + 2)(1)\nconst add2 = a =&gt; a + 2;\nlog(appy1(add2));   // 3</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const times = (f, n) =&gt; {\n\tlet i = -1;\n\twhile (++i &lt; n) f(i);\n}\n\ntimes(log, 3);\ntimes(a =&gt; log(a + 10), 3);</code>\n        </deckgo-highlight-code>\n<h3>함수를 만들어 리턴하는 함수</h3>\n<ul>\n<li>함수가 함수를 리턴하는 것은 클로저를 만들기 위해서이다.\n<ul>\n<li>클로저: 함수가 특정값을 기억하는 함수이다.</li>\n</ul>\n</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const addMaker = a =&gt; b =&gt; a + b;   // 클로저를 리턴하는 함수\nconst add10 = addMaker(10);   // add10 함수는 b =&gt; 10 + b라는 함수로 a(10)을 기억함\nlog(add10(5));</code>\n        </deckgo-highlight-code>","frontmatter":{"title":"함수형 자바스크립트 기본기","date":"2022년 9월 19일 오전 12:51","summary":"함수형 자바스크립트의 평가와 일급","categories":["JavaScript"]}}},{"node":{"id":"b63f8515-7752-592c-9dc7-017c6291da03","fields":{"slug":"/javascript/generator 문법/"},"html":"<p>ES6에서 도입된 제너레이터(Generator) 함수는 이터러블을 생성하는 함수이다. 제너레이터 함수를 사용하면 이터레이터 프로토콜을 준수해 이터러블을 생성하는 방식보다 간편하게 이터러블을 구현할 수 있다. 또한 제너레이터 함수는 비동기 처리에 유용하게 사용된다.</p>\n<p>Generator는 빠져나갔다가 나중에 돌아올 수 있는 함수이다. 이때 변수 값은 출입 과정에서 저장된 상태로 남아 있다는 점 기억하기 !!</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function* generator(i) {\n\tyield i;\n\tyield i + 10;\n}</code>\n        </deckgo-highlight-code>\n<h3>참고</h3>\n<ul>\n<li>MDN Generator</li>\n</ul>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Generator\" target=\"_blank\" rel=\"nofollow\">Generator - JavaScript | MDN</a></p>","frontmatter":{"title":"generator 문법","date":"2022년 1월 27일 오전 11:38","summary":"Gernerator 함수","categories":["JavaScript","ES6+"]}}},{"node":{"id":"843c98e9-3ba8-520d-bd4a-ecbaeb6b31f3","fields":{"slug":"/javascript/ES6에서의 순회와 이터러블 이터레이터 프로토콜/"},"html":"<h2>기존과 달라진 ES6에서의 리스트 순회</h2>\n<p>: for i++ 의 index 방식에서 for…of 의 iterator방식으로 변경되었다.</p>\n<ul>\n<li>기존 리스트 순회</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const list = [1, 2, 3];\nfor( var i = 0; i&lt; list.length; i++){\n\tlog(list[i]);\n}\n\n// 유사 배열 순회\nconst str = &#39;abc&#39;;\nfor( var i = 0; i&lt; str.length; i++){\n\tlog(str[i]);\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>변경된 리스트 순회</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">for (const a of list) {\n\tlog(a);\n}\n\nfor (const a of str) {\n\tlog(a);\n}</code>\n        </deckgo-highlight-code>\n<h2>Array, Set, Map를 통해 알아보기</h2>\n<ul>\n<li>Array를 통해 알아보기</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const arr = [1, 2, 3];\nfor (const a of arr) log(a);   // 1, 2, 3\n</code>\n        </deckgo-highlight-code>\n<ul>\n<li>Set을 통해 알아보기</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const set = new Set([1, 2, 3]);\nfor (const a of set) log(a);   // 1, 2, 3</code>\n        </deckgo-highlight-code>\n<ul>\n<li>Map을 통해 알아보기</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const map = new Map([[&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]]);\nfor (const a of map) log(a);   // 1, 2, 3</code>\n        </deckgo-highlight-code>\n<p>: 해당 함수를 통해 반환되는 값들도 Iterator형태이기 때문에 <code>map.values(), map.keys(), map.entries()</code>도 정상동작한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const map = new Map([[&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]]);\nfor (const a of map.keys()) log(a);\nfor (const a of map.values()) log(a);\nfor (const a of map.entries()) log(a);</code>\n        </deckgo-highlight-code>\n<h2>이터러블/이터레이터 프로토콜</h2>\n<ul>\n<li>이터러블: 이터레이터를 리턴하는 <code>[Symbol.iterator]()</code> 를 가진 값.</li>\n<li>이터레이터: <code>{ value, done }</code> 객체를 리턴하는 <code>next()</code> 를 가진 값.</li>\n<li>이터러블/이터레이터 프로토콜: 이터러블을 <code>for…of</code>, 전개 연산자 등과 함께 동작 하도록 한 규약.</li>\n</ul>\n<h3>사용자 정의 이터러블</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const iterable = {\n\t[Symbol.iterator]() {\n\t\tlet i = 3;\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\treturn i === 0 ? { done: true } : { value: i--, done: false };\n\t\t\t},\n\t\t\t[Symbol.iterator]() { return this; }  // 자기 자신을 반환하는 로직\n\t\t}\n\t}\n};\n\nlet iterator = iterable[Symbol.iterator]();\nfor (const a of iterable) log(a);\nfor (const a of iterator) log(a);   // 위의 로직을 추가해주어야 오류 없이 동작한다.\n\nconst arr = [1, 2, 3];\nlet iter2 = arr[Symbol.iterator]();\nlog(iter2[Symbol.iterator]() == iter2);</code>\n        </deckgo-highlight-code>\n<p>📌  <strong>잘 만든 이터러블이란 ?!</strong></p>\n<ul>\n<li>이터러블을 만들어서 순회할 때 잘 동작한다.</li>\n<li>일부 진행한 이후에는 진행된 결과 이후의 값들로 진행이 된다.</li>\n<li>자기 자신을 반환하는 <code>Symbol.iterator</code>를 가지고 있어야 한다.</li>\n</ul>\n<p>DOM도 Iterator를 통해 순회가 가능하다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">for (const a of document.querySelectAll(&#39;*&#39;)) log(a);</code>\n        </deckgo-highlight-code>\n<h2>전개 연산자 (=나머지 연산자)</h2>\n<ul>\n<li>전개 연산자도 이터러블/이터레이터 프로토콜을 따른다.</li>\n<li>iterator를 null로 변경하면 에러가 발생한다.</li>\n</ul>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const a = [1, 2];\na[Symbol.iterator] = null; \nlog([...a, ...[3,4]);   // Uncaught TypeError: a is not iterable\n\nconsole.log([...a, ...[3, 4]]);   // [1, 2, 3, 4]</code>\n        </deckgo-highlight-code>","frontmatter":{"title":"ES6에서의 순회와 이터러블:이터레이터 프로토콜","date":"2022년 9월 18일 오후 2:34","summary":"ES6에서의 이터레이터 프로토콜과 이터러블","categories":["JavaScript"]}}}]}},"pageContext":{"fieldValue":"JavaScript","totalCount":10}},
    "staticQueryHashes": ["3764592887"]}